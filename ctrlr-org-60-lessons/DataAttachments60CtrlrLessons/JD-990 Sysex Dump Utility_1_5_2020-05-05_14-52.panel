<?xml version="1.0" encoding="UTF-8"?>

<panel name="JD-990 Sysex Dump Utility" panelShowDialogs="1" panelMessageTime="10000"
       panelAuthorName="John Goodland (Dnaldoog)" panelAuthorEmail="zan642@gmail.com"
       panelAuthorUrl="" panelAuthorDesc="A small utitilty for transferring Internal Patch I-11 to I-88 (64 patches) to external sysex file"
       panelVersionMajor="1" panelVersionMinor="5" panelVersionName=""
       panelVendor="" panelDevice="Roland JD-990 Synthesizer Module"
       panelMidiSnapshotAfterLoad="0" panelMidiSnapshotAfterProgramChange="0"
       panelMidiSnapshotDelay="10" panelMidiSnapshotShowProgress="0"
       panelMidiInputChannelDevice="1" panelMidiInputDevice="-- None"
       panelMidiControllerChannelDevice="1" panelMidiControllerDevice="-- None"
       panelMidiOutputChannelDevice="1" panelMidiOutputDevice="-- None"
       panelMidiInputFromHost="0" panelMidiInputChannelHost="1" panelMidiOutputToHost="0"
       panelMidiOutputChannelHost="1" panelMidiThruH2H="0" panelMidiThruH2HChannelize="0"
       panelMidiThruH2D="0" panelMidiThruH2DChannelize="0" panelMidiThruD2D="0"
       panelMidiThruD2DChannelize="0" panelMidiThruD2H="0" panelMidiThruD2HChannelize="0"
       panelMidiRealtimeIgnore="1" panelMidiInputThreadPriority="7"
       panelMidiProgram="0" panelMidiBankLsb="0" panelMidiBankMsb="0"
       panelMidiSendProgramChangeOnLoad="0" panelMidiProgramCalloutOnprogramChange="0"
       panelMidiMatchCacheSize="32" panelMidiGlobalDelay="0" panelMidiPauseOut="0"
       panelMidiPauseIn="0" panelOSCEnabled="0" panelOSCPort="-1" panelOSCProtocol="0"
       luaPanelMidiChannelChanged="-- None" luaPanelMidiReceived="myMidiReceived"
       luaPanelMidiMultiReceived="-- None" luaPanelLoaded="initialise"
       luaPanelBeforeLoad="-- None" luaPanelSaved="-- None" luaPanelResourcesLoaded="-- None"
       luaPanelProgramChanged="-- None" luaPanelGlobalChanged="-- None"
       luaPanelMessageHandler="-- None" luaPanelModulatorValueChanged="-- None"
       luaPanelSaveState="-- None" luaPanelRestoreState="-- None" luaPanelMidiSnapshotPost="-- None"
       luaPanelMidiSnapshotPre="-- None" luaAudioProcessBlock="-- None"
       luaPanelOSCReceived="-- None" panelFilePath="D:\IR\Ctrlr_panels\checksum.panel"
       panelUID="8.OFspVx83AbA" panelInstanceUID="Jcrg" panelInstanceManufacturerID="RYwT"
       panelModulatorListColumns="&lt;TABLELAYOUT sortedCol=&quot;613&quot; sortForwards=&quot;1&quot;&gt;&lt;COLUMN id=&quot;611&quot; visible=&quot;1&quot; width=&quot;169&quot;/&gt;&lt;COLUMN id=&quot;612&quot; visible=&quot;1&quot; width=&quot;350&quot;/&gt;&lt;COLUMN id=&quot;1&quot; visible=&quot;1&quot; width=&quot;330&quot;/&gt;&lt;COLUMN id=&quot;613&quot; visible=&quot;1&quot; width=&quot;350&quot;/&gt;&lt;COLUMN id=&quot;123&quot; visible=&quot;1&quot; width=&quot;405&quot;/&gt;&lt;COLUMN id=&quot;127&quot; visible=&quot;1&quot; width=&quot;313&quot;/&gt;&lt;/TABLELAYOUT&gt;"
       panelModulatorListCsvDelimiter="," panelModulatorListXmlRoot="ctrlrModulatorList"
       panelModulatorListXmlModulator="ctrlrModulator" panelModulatorListSortOption="1"
       panelGlobalVariables="0:0:0:-1:0:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:0:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1:-1"
       panelResources="-- None" panelPropertyDisplayIDs="0" ctrlrMenuItemBackgroundColour="ffffffff"
       ctrlrMenuItemTextColour="ff000000" ctrlrMenuItemHighlightedTextColour="ffffffff"
       ctrlrMenuItemHighlightColour="ff4364ff" ctrlrMenuItemFont="&lt;Sans-Serif&gt;;18;0;0;0;0;1;3"
       ctrlrMenuItemSeparatorColour="44000000" ctrlrMenuItemHeaderColour="ff000000"
       ctrlrMenuBarBackgroundColour1="fff7f7f7" ctrlrMenuBarBackgroundColour2="ffcccccc"
       ctrlrMenuBarTextColour="ff000000" ctrlrMenuBarHighlightedTextColour="ffffffff"
       ctrlrMenuBarHighlightColour="ff4364ff" ctrlrMenuBarFont="&lt;Sans-Serif&gt;;18;0;0;0;0;1;3"
       ctrlrUseEditorWrapper="0" panelIndex="0" uiPanelModulatorListViewTree="0">
  <uiWindowManager>
    <uiChildWindow uiChildWindowName="LuaMethodEditor" uiChildWindowState="0 0 1240 1024">
      <uiChildWindowContentState luaMethodEditor="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#13;&#10;&#13;&#10;&lt;OPEN id=&quot;LUA&quot; scrollPos=&quot;0&quot;&gt;&#13;&#10;  &lt;OPEN id=&quot;myMethods&quot;/&gt;&#13;&#10;  &lt;SELECTED id=&quot;/LUA/myMethods/downloadSysex&quot;/&gt;&#13;&#10;&lt;/OPEN&gt;&#13;&#10;;134ebcd9c84a4d308ac441bfdbfa1692"
                                 luaMethodEditorFont="Courier New;14;0;0;0;0;1;0" luaMethodEditorBgColour="ffffffff"/>
    </uiChildWindow>
    <uiChildWindow uiChildWindowName="LuaConsole" uiChildWindowState="93 609 800 419">
      <uiChildWindowContentState/>
    </uiChildWindow>
    <uiChildWindow uiChildWindowName="ModulatorList" uiChildWindowState="fs 0 0 800 500">
      <uiChildWindowContentState/>
    </uiChildWindow>
    <uiChildWindow uiChildWindowName="LayerEditor" uiChildWindowState="560 270 800 500">
      <uiChildWindowContentState/>
    </uiChildWindow>
  </uiWindowManager>
  <midiLibrary uuid="7b1d39f6206b41a8a85cb286766b5283" luaTransInfo="-- None"
               midiLibraryParameterIndexProperty="modulatorCustomIndex" midiLibraryMidiProgramChangeControl="0"
               midiLibrarySendSnapAfterPChg="0" midiLibraryDefaultBankName="New Bank - %H:%M:%S"
               midiLibraryDefaultProgramName="New Program - %H:%M:%S" midiLibraryDefaultSnapshotName="Snapshot - %H:%M:%S"
               midiLibraryCustomRequests="">
    <midiLibrarySnapshots name="Snapshots"/>
    <midiLibraryFirmware name="Firmware"/>
    <midiLibraryEditBuffer name="Edit buffer"/>
    <midiLibraryTransactions name="Transactions"/>
  </midiLibrary>
  <luaManager>
    <luaManagerMethods>
      <luaMethodGroup name="Built-In" uuid="1e55ce6dfc9e4c528210ff61b6137e68">
        <luaMethod luaMethodName="table_dump" luaMethodCode="-- @1.1&#13;&#10;--&#13;&#10;-- Print table contents&#13;&#10;--&#13;&#10;function table_dump(table)&#13;&#10;&#9;for key,value in ipairs(table) do&#13;&#10;&#9;&#9;_DBG (&quot;KEY= [&quot;..key..&quot;]&quot;)&#13;&#10;&#13;&#10;&#9;&#9;if (type(value) == &quot;table&quot;) then&#13;&#10;&#9;&#9;&#9;table_dump(value)&#13;&#10;&#9;&#9;elseif (type(value) == &quot;nil&quot;) then&#13;&#10;&#9;&#9;&#9;_DBG (&quot; = NIL&quot;)&#13;&#10;&#9;&#9;else&#13;&#10;&#9;&#9;&#9;what (value)&#13;&#10;&#9;&#9;end&#13;&#10;&#9;end&#13;&#10;end"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="00000000000000000000000000000001"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="what" luaMethodCode="-- @1.1&#13;&#10;--&#13;&#10;-- Print methods for an object&#13;&#10;--&#13;&#10;function what(o)&#13;&#10;&#9;info = class_info(o)&#13;&#10;&#9;if info ~= nil then&#13;&#10;&#9;&#9;ret = &quot;Object type [&quot; .. info.name .. &quot;]\n-----------------------------------------------------------------\n\n&quot;..&quot;Members:\n&quot;&#13;&#10;&#13;&#10;&#9;&#9;if info.name == &quot;table&quot; then&#13;&#10;&#9;&#9;&#9;table_dump(o)&#13;&#10;&#9;&#9;end&#13;&#10;&#13;&#10;&#9;&#9;for k, v in pairs(info.methods) do&#13;&#10;&#9;&#9;&#9;ret = ret .. string.format (&quot;\t%30s:\t%5s\n&quot;, k, type(v))&#13;&#10;&#9;&#9;end&#13;&#10;&#9;&#9;ret = ret .. &quot;\n\nAttributes:\n&quot;&#13;&#10;&#9;&#9;for k, v in pairs(info.attributes) do&#13;&#10;&#9;&#9;&#9;ret = ret .. string.format (&quot;\t%30s:\t%5s\n&quot;, k, type(v))&#13;&#10;&#9;&#9;end&#13;&#10;&#9;&#9;ret = ret .. &quot;\n-----------------------------------------------------------------&quot;&#13;&#10;&#9;end&#13;&#10;&#13;&#10;&#9;console (ret)&#13;&#10;&#9;return ret&#13;&#10;end"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="00000000000000000000000000000002"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="how" luaMethodCode="-- @1.1&#13;&#10;--&#13;&#10;-- Print all available classes&#13;&#10;--&#13;&#10;function how()&#13;&#10;&#9;ret = &quot;Available classes:\n&quot;&#13;&#10;&#9;ret = ret .. &quot;\n-----------------------------------------------------------------&quot;&#13;&#10;&#9;for i,v in ipairs(class_names()) do&#13;&#10;&#9;&#9;ret = ret .. &quot;\t&quot;.. v .. &quot;\n&quot;&#13;&#10;&#9;end&#13;&#10;&#9;ret = ret .. &quot;\n-----------------------------------------------------------------&quot;&#13;&#10;&#9;console (J(ret))&#13;&#10;&#9;return ret&#13;&#10;end"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="00000000000000000000000000000003"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="json4lua" luaMethodCode="-----------------------------------------------------------------------------&#13;&#10;-- JSON4Lua: JSON encoding / decoding support for the Lua language.&#13;&#10;-- json Module.&#13;&#10;-- Author: Craig Mason-Jones&#13;&#10;-- Homepage: http://json.luaforge.net/&#13;&#10;-- Version: 0.9.40&#13;&#10;-- This module is released under the MIT License (MIT).&#13;&#10;-- Please see LICENCE.txt for details.&#13;&#10;--&#13;&#10;-- USAGE:&#13;&#10;-- This module exposes two functions:&#13;&#10;--   encode(o)&#13;&#10;--     Returns the table / string / boolean / number / nil / json.null value as a JSON-encoded string.&#13;&#10;--   decode(json_string)&#13;&#10;--     Returns a Lua object populated with the data encoded in the JSON string json_string.&#13;&#10;--&#13;&#10;-- REQUIREMENTS:&#13;&#10;--   compat-5.1 if using Lua 5.0&#13;&#10;--&#13;&#10;-- CHANGELOG&#13;&#10;--   0.9.20 Introduction of local Lua functions for private functions (removed _ function prefix). &#13;&#10;--          Fixed Lua 5.1 compatibility issues.&#13;&#10;--   &#9;&#9;Introduced json.null to have null values in associative arrays.&#13;&#10;--          encode() performance improvement (more than 50%) through table.concat rather than ..&#13;&#10;--          Introduced decode ability to ignore /**/ comments in the JSON string.&#13;&#10;--   0.9.10 Fix to array encoding / decoding to correctly manage nil/null values in arrays.&#13;&#10;-----------------------------------------------------------------------------&#13;&#10;&#13;&#10;-----------------------------------------------------------------------------&#13;&#10;-- Imports and dependencies&#13;&#10;-----------------------------------------------------------------------------&#13;&#10;local math = require('math')&#13;&#10;local string = require(&quot;string&quot;)&#13;&#10;local table = require(&quot;table&quot;)&#13;&#10;&#13;&#10;local base = _G&#13;&#10;&#13;&#10;-----------------------------------------------------------------------------&#13;&#10;-- Module declaration&#13;&#10;-----------------------------------------------------------------------------&#13;&#10;module(&quot;json&quot;)&#13;&#10;&#13;&#10;-- Public functions&#13;&#10;&#13;&#10;-- Private functions&#13;&#10;local decode_scanArray&#13;&#10;local decode_scanComment&#13;&#10;local decode_scanConstant&#13;&#10;local decode_scanNumber&#13;&#10;local decode_scanObject&#13;&#10;local decode_scanString&#13;&#10;local decode_scanWhitespace&#13;&#10;local encodeString&#13;&#10;local isArray&#13;&#10;local isEncodable&#13;&#10;&#13;&#10;-----------------------------------------------------------------------------&#13;&#10;-- PUBLIC FUNCTIONS&#13;&#10;-----------------------------------------------------------------------------&#13;&#10;--- Encodes an arbitrary Lua object / variable.&#13;&#10;-- @param v The Lua object / variable to be JSON encoded.&#13;&#10;-- @return String containing the JSON encoding in internal Lua string format (i.e. not unicode)&#13;&#10;function encode (v)&#13;&#10;  -- Handle nil values&#13;&#10;  if v==nil then&#13;&#10;    return &quot;null&quot;&#13;&#10;  end&#13;&#10;  &#13;&#10;  local vtype = base.type(v)  &#13;&#10;&#13;&#10;  -- Handle strings&#13;&#10;  if vtype=='string' then    &#13;&#10;    return '&quot;' .. encodeString(v) .. '&quot;'&#9;    -- Need to handle encoding in string&#13;&#10;  end&#13;&#10;  &#13;&#10;  -- Handle booleans&#13;&#10;  if vtype=='number' or vtype=='boolean' then&#13;&#10;    return base.tostring(v)&#13;&#10;  end&#13;&#10;  &#13;&#10;  -- Handle tables&#13;&#10;  if vtype=='table' then&#13;&#10;    local rval = {}&#13;&#10;    -- Consider arrays separately&#13;&#10;    local bArray, maxCount = isArray(v)&#13;&#10;    if bArray then&#13;&#10;      for i = 1,maxCount do&#13;&#10;        table.insert(rval, encode(v[i]))&#13;&#10;      end&#13;&#10;    else&#9;-- An object, not an array&#13;&#10;      for i,j in base.pairs(v) do&#13;&#10;        if isEncodable(i) and isEncodable(j) then&#13;&#10;          table.insert(rval, '&quot;' .. encodeString(i) .. '&quot;:' .. encode(j))&#13;&#10;        end&#13;&#10;      end&#13;&#10;    end&#13;&#10;    if bArray then&#13;&#10;      return '[' .. table.concat(rval,',') ..']'&#13;&#10;    else&#13;&#10;      return '{' .. table.concat(rval,',') .. '}'&#13;&#10;    end&#13;&#10;  end&#13;&#10;  &#13;&#10;  -- Handle null values&#13;&#10;  if vtype=='function' and v==null then&#13;&#10;    return 'null'&#13;&#10;  end&#13;&#10;  &#13;&#10;  base.assert(false,'encode attempt to encode unsupported type ' .. vtype .. ':' .. base.tostring(v))&#13;&#10;end&#13;&#10;&#13;&#10;&#13;&#10;--- Decodes a JSON string and returns the decoded value as a Lua data structure / value.&#13;&#10;-- @param s The string to scan.&#13;&#10;-- @param [startPos] Optional starting position where the JSON string is located. Defaults to 1.&#13;&#10;-- @param Lua object, number The object that was scanned, as a Lua table / string / number / boolean or nil,&#13;&#10;-- and the position of the first character after&#13;&#10;-- the scanned JSON object.&#13;&#10;function decode(s, startPos)&#13;&#10;  startPos = startPos and startPos or 1&#13;&#10;  startPos = decode_scanWhitespace(s,startPos)&#13;&#10;  base.assert(startPos&lt;=string.len(s), 'Unterminated JSON encoded object found at position in [' .. s .. ']')&#13;&#10;  local curChar = string.sub(s,startPos,startPos)&#13;&#10;  -- Object&#13;&#10;  if curChar=='{' then&#13;&#10;    return decode_scanObject(s,startPos)&#13;&#10;  end&#13;&#10;  -- Array&#13;&#10;  if curChar=='[' then&#13;&#10;    return decode_scanArray(s,startPos)&#13;&#10;  end&#13;&#10;  -- Number&#13;&#10;  if string.find(&quot;+-0123456789.e&quot;, curChar, 1, true) then&#13;&#10;    return decode_scanNumber(s,startPos)&#13;&#10;  end&#13;&#10;  -- String&#13;&#10;  if curChar==[[&quot;]] or curChar==[[']] then&#13;&#10;    return decode_scanString(s,startPos)&#13;&#10;  end&#13;&#10;  if string.sub(s,startPos,startPos+1)=='/*' then&#13;&#10;    return decode(s, decode_scanComment(s,startPos))&#13;&#10;  end&#13;&#10;  -- Otherwise, it must be a constant&#13;&#10;  return decode_scanConstant(s,startPos)&#13;&#10;end&#13;&#10;&#13;&#10;--- The null function allows one to specify a null value in an associative array (which is otherwise&#13;&#10;-- discarded if you set the value with 'nil' in Lua. Simply set t = { first=json.null }&#13;&#10;function null()&#13;&#10;  return null -- so json.null() will also return null ;-)&#13;&#10;end&#13;&#10;-----------------------------------------------------------------------------&#13;&#10;-- Internal, PRIVATE functions.&#13;&#10;-- Following a Python-like convention, I have prefixed all these 'PRIVATE'&#13;&#10;-- functions with an underscore.&#13;&#10;-----------------------------------------------------------------------------&#13;&#10;&#13;&#10;--- Scans an array from JSON into a Lua object&#13;&#10;-- startPos begins at the start of the array.&#13;&#10;-- Returns the array and the next starting position&#13;&#10;-- @param s The string being scanned.&#13;&#10;-- @param startPos The starting position for the scan.&#13;&#10;-- @return table, int The scanned array as a table, and the position of the next character to scan.&#13;&#10;function decode_scanArray(s,startPos)&#13;&#10;  local array = {}&#9;-- The return value&#13;&#10;  local stringLen = string.len(s)&#13;&#10;  base.assert(string.sub(s,startPos,startPos)=='[','decode_scanArray called but array does not start at position ' .. startPos .. ' in string:\n'..s )&#13;&#10;  startPos = startPos + 1&#13;&#10;  -- Infinite loop for array elements&#13;&#10;  repeat&#13;&#10;    startPos = decode_scanWhitespace(s,startPos)&#13;&#10;    base.assert(startPos&lt;=stringLen,'JSON String ended unexpectedly scanning array.')&#13;&#10;    local curChar = string.sub(s,startPos,startPos)&#13;&#10;    if (curChar==']') then&#13;&#10;      return array, startPos+1&#13;&#10;    end&#13;&#10;    if (curChar==',') then&#13;&#10;      startPos = decode_scanWhitespace(s,startPos+1)&#13;&#10;    end&#13;&#10;    base.assert(startPos&lt;=stringLen, 'JSON String ended unexpectedly scanning array.')&#13;&#10;    object, startPos = decode(s,startPos)&#13;&#10;    table.insert(array,object)&#13;&#10;  until false&#13;&#10;end&#13;&#10;&#13;&#10;--- Scans a comment and discards the comment.&#13;&#10;-- Returns the position of the next character following the comment.&#13;&#10;-- @param string s The JSON string to scan.&#13;&#10;-- @param int startPos The starting position of the comment&#13;&#10;function decode_scanComment(s, startPos)&#13;&#10;  base.assert( string.sub(s,startPos,startPos+1)=='/*', &quot;decode_scanComment called but comment does not start at position &quot; .. startPos)&#13;&#10;  local endPos = string.find(s,'*/',startPos+2)&#13;&#10;  base.assert(endPos~=nil, &quot;Unterminated comment in string at &quot; .. startPos)&#13;&#10;  return endPos+2  &#13;&#10;end&#13;&#10;&#13;&#10;--- Scans for given constants: true, false or null&#13;&#10;-- Returns the appropriate Lua type, and the position of the next character to read.&#13;&#10;-- @param s The string being scanned.&#13;&#10;-- @param startPos The position in the string at which to start scanning.&#13;&#10;-- @return object, int The object (true, false or nil) and the position at which the next character should be &#13;&#10;-- scanned.&#13;&#10;function decode_scanConstant(s, startPos)&#13;&#10;  local consts = { [&quot;true&quot;] = true, [&quot;false&quot;] = false, [&quot;null&quot;] = nil }&#13;&#10;  local constNames = {&quot;true&quot;,&quot;false&quot;,&quot;null&quot;}&#13;&#10;&#13;&#10;  for i,k in base.pairs(constNames) do&#13;&#10;    --print (&quot;[&quot; .. string.sub(s,startPos, startPos + string.len(k) -1) ..&quot;]&quot;, k)&#13;&#10;    if string.sub(s,startPos, startPos + string.len(k) -1 )==k then&#13;&#10;      return consts[k], startPos + string.len(k)&#13;&#10;    end&#13;&#10;  end&#13;&#10;  base.assert(nil, 'Failed to scan constant from string ' .. s .. ' at starting position ' .. startPos)&#13;&#10;end&#13;&#10;&#13;&#10;--- Scans a number from the JSON encoded string.&#13;&#10;-- (in fact, also is able to scan numeric +- eqns, which is not&#13;&#10;-- in the JSON spec.)&#13;&#10;-- Returns the number, and the position of the next character&#13;&#10;-- after the number.&#13;&#10;-- @param s The string being scanned.&#13;&#10;-- @param startPos The position at which to start scanning.&#13;&#10;-- @return number, int The extracted number and the position of the next character to scan.&#13;&#10;function decode_scanNumber(s,startPos)&#13;&#10;  local endPos = startPos+1&#13;&#10;  local stringLen = string.len(s)&#13;&#10;  local acceptableChars = &quot;+-0123456789.e&quot;&#13;&#10;  while (string.find(acceptableChars, string.sub(s,endPos,endPos), 1, true)&#13;&#10;&#9;and endPos&lt;=stringLen&#13;&#10;&#9;) do&#13;&#10;    endPos = endPos + 1&#13;&#10;  end&#13;&#10;  local stringValue = 'return ' .. string.sub(s,startPos, endPos-1)&#13;&#10;  local stringEval = base.loadstring(stringValue)&#13;&#10;  base.assert(stringEval, 'Failed to scan number [ ' .. stringValue .. '] in JSON string at position ' .. startPos .. ' : ' .. endPos)&#13;&#10;  return stringEval(), endPos&#13;&#10;end&#13;&#10;&#13;&#10;--- Scans a JSON object into a Lua object.&#13;&#10;-- startPos begins at the start of the object.&#13;&#10;-- Returns the object and the next starting position.&#13;&#10;-- @param s The string being scanned.&#13;&#10;-- @param startPos The starting position of the scan.&#13;&#10;-- @return table, int The scanned object as a table and the position of the next character to scan.&#13;&#10;function decode_scanObject(s,startPos)&#13;&#10;  local object = {}&#13;&#10;  local stringLen = string.len(s)&#13;&#10;  local key, value&#13;&#10;  base.assert(string.sub(s,startPos,startPos)=='{','decode_scanObject called but object does not start at position ' .. startPos .. ' in string:\n' .. s)&#13;&#10;  startPos = startPos + 1&#13;&#10;  repeat&#13;&#10;    startPos = decode_scanWhitespace(s,startPos)&#13;&#10;    base.assert(startPos&lt;=stringLen, 'JSON string ended unexpectedly while scanning object.')&#13;&#10;    local curChar = string.sub(s,startPos,startPos)&#13;&#10;    if (curChar=='}') then&#13;&#10;      return object,startPos+1&#13;&#10;    end&#13;&#10;    if (curChar==',') then&#13;&#10;      startPos = decode_scanWhitespace(s,startPos+1)&#13;&#10;    end&#13;&#10;    base.assert(startPos&lt;=stringLen, 'JSON string ended unexpectedly scanning object.')&#13;&#10;    -- Scan the key&#13;&#10;    key, startPos = decode(s,startPos)&#13;&#10;    base.assert(startPos&lt;=stringLen, 'JSON string ended unexpectedly searching for value of key ' .. key)&#13;&#10;    startPos = decode_scanWhitespace(s,startPos)&#13;&#10;    base.assert(startPos&lt;=stringLen, 'JSON string ended unexpectedly searching for value of key ' .. key)&#13;&#10;    base.assert(string.sub(s,startPos,startPos)==':','JSON object key-value assignment mal-formed at ' .. startPos)&#13;&#10;    startPos = decode_scanWhitespace(s,startPos+1)&#13;&#10;    base.assert(startPos&lt;=stringLen, 'JSON string ended unexpectedly searching for value of key ' .. key)&#13;&#10;    value, startPos = decode(s,startPos)&#13;&#10;    object[key]=value&#13;&#10;  until false&#9;-- infinite loop while key-value pairs are found&#13;&#10;end&#13;&#10;&#13;&#10;-- START SoniEx2&#13;&#10;-- Initialize some things used by decode_scanString&#13;&#10;-- You know, for efficiency&#13;&#10;local escapeSequences = {&#13;&#10;  [&quot;\\t&quot;] = &quot;\t&quot;,&#13;&#10;  [&quot;\\f&quot;] = &quot;\f&quot;,&#13;&#10;  [&quot;\\r&quot;] = &quot;\r&quot;,&#13;&#10;  [&quot;\\n&quot;] = &quot;\n&quot;,&#13;&#10;  [&quot;\\b&quot;] = &quot;\b&quot;&#13;&#10;}&#13;&#10;base.setmetatable(escapeSequences, {__index = function(t,k)&#13;&#10;  -- skip &quot;\&quot; aka strip escape&#13;&#10;  return string.sub(k,2)&#13;&#10;end})&#13;&#10;-- END SoniEx2&#13;&#10;&#13;&#10;--- Scans a JSON string from the opening inverted comma or single quote to the&#13;&#10;-- end of the string.&#13;&#10;-- Returns the string extracted as a Lua string,&#13;&#10;-- and the position of the next non-string character&#13;&#10;-- (after the closing inverted comma or single quote).&#13;&#10;-- @param s The string being scanned.&#13;&#10;-- @param startPos The starting position of the scan.&#13;&#10;-- @return string, int The extracted string as a Lua string, and the next character to parse.&#13;&#10;function decode_scanString(s,startPos)&#13;&#10;  base.assert(startPos, 'decode_scanString(..) called without start position')&#13;&#10;  local startChar = string.sub(s,startPos,startPos)&#13;&#10;  -- START SoniEx2&#13;&#10;  -- PS: I don't think single quotes are valid JSON&#13;&#10;  base.assert(startChar == [[&quot;]] or startChar == [[']],'decode_scanString called for a non-string')&#13;&#10;  --base.assert(startPos, &quot;String decoding failed: missing closing &quot; .. startChar .. &quot; for string at position &quot; .. oldStart)&#13;&#10;  local t = {}&#13;&#10;  local i,j = startPos,startPos&#13;&#10;  while string.find(s, startChar, j+1) ~= j+1 do&#13;&#10;    local oldj = j&#13;&#10;    i,j = string.find(s, &quot;\\.&quot;, j+1)&#13;&#10;    local x,y = string.find(s, startChar, oldj+1)&#13;&#10;    if not i or x &lt; i then&#13;&#10;      base.print(s, startPos, string.sub(s,startPos,oldj))&#13;&#10;      i,j = x,y-1&#13;&#10;      if not x then base.print(s, startPos, string.sub(s,startPos,oldj)) end&#13;&#10;    end&#13;&#10;    table.insert(t, string.sub(s, oldj+1, i-1))&#13;&#10;    if string.sub(s, i, j) == &quot;\\u&quot; then&#13;&#10;      local a = string.sub(s,j+1,j+4)&#13;&#10;      j = j + 4&#13;&#10;      local n = base.tonumber(a, 16)&#13;&#10;      base.assert(n, &quot;String decoding failed: bad Unicode escape &quot; .. a .. &quot; at position &quot; .. i .. &quot; : &quot; .. j)&#13;&#10;      -- math.floor(x/2&#94;y) == lazy right shift&#13;&#10;      -- a % 2&#94;b == bitwise_and(a, (2&#94;b)-1)&#13;&#10;      -- 64 = 2&#94;6&#13;&#10;      -- 4096 = 2&#94;12 (or 2&#94;6 * 2&#94;6)&#13;&#10;      local x&#13;&#10;      if n &lt; 0x80 then&#13;&#10;        x = string.char(n % 0x80)&#13;&#10;      elseif n &lt; 0x800 then&#13;&#10;        -- [110x xxxx] [10xx xxxx]&#13;&#10;        x = string.char(0xC0 + (math.floor(n/64) % 0x20), 0x80 + (n % 0x40))&#13;&#10;      else&#13;&#10;        -- [1110 xxxx] [10xx xxxx] [10xx xxxx]&#13;&#10;        x = string.char(0xE0 + (math.floor(n/4096) % 0x10), 0x80 + (math.floor(n/64) % 0x40), 0x80 + (n % 0x40))&#13;&#10;      end&#13;&#10;      table.insert(t, x)&#13;&#10;    else&#13;&#10;      table.insert(t, escapeSequences[string.sub(s, i, j)])&#13;&#10;    end&#13;&#10;  end&#13;&#10;  table.insert(t,string.sub(j, j+1))&#13;&#10;  base.assert(string.find(s, startChar, j+1), &quot;String decoding failed: missing closing &quot; .. startChar .. &quot; at position &quot; .. j .. &quot;(for string at position &quot; .. startPos .. &quot;)&quot;)&#13;&#10;  return table.concat(t,&quot;&quot;), j+2&#13;&#10;  -- END SoniEx2&#13;&#10;end&#13;&#10;&#13;&#10;--- Scans a JSON string skipping all whitespace from the current start position.&#13;&#10;-- Returns the position of the first non-whitespace character, or nil if the whole end of string is reached.&#13;&#10;-- @param s The string being scanned&#13;&#10;-- @param startPos The starting position where we should begin removing whitespace.&#13;&#10;-- @return int The first position where non-whitespace was encountered, or string.len(s)+1 if the end of string&#13;&#10;-- was reached.&#13;&#10;function decode_scanWhitespace(s,startPos)&#13;&#10;  local whitespace=&quot; \n\r\t&quot;&#13;&#10;  local stringLen = string.len(s)&#13;&#10;  while ( string.find(whitespace, string.sub(s,startPos,startPos), 1, true)  and startPos &lt;= stringLen) do&#13;&#10;    startPos = startPos + 1&#13;&#10;  end&#13;&#10;  return startPos&#13;&#10;end&#13;&#10;&#13;&#10;--- Encodes a string to be JSON-compatible.&#13;&#10;-- This just involves back-quoting inverted commas, back-quotes and newlines, I think ;-)&#13;&#10;-- @param s The string to return as a JSON encoded (i.e. backquoted string)&#13;&#10;-- @return The string appropriately escaped.&#13;&#10;&#13;&#10;local escapeList = {&#13;&#10;    ['&quot;']  = '\\&quot;',&#13;&#10;    ['\\'] = '\\\\',&#13;&#10;    ['/']  = '\\/', &#13;&#10;    ['\b'] = '\\b',&#13;&#10;    ['\f'] = '\\f',&#13;&#10;    ['\n'] = '\\n',&#13;&#10;    ['\r'] = '\\r',&#13;&#10;    ['\t'] = '\\t'&#13;&#10;}&#13;&#10;&#13;&#10;function encodeString(s)&#13;&#10; return s:gsub(&quot;.&quot;, function(c) return escapeList[c] end) -- SoniEx2: 5.0 compat&#13;&#10;end&#13;&#10;&#13;&#10;-- Determines whether the given Lua type is an array or a table / dictionary.&#13;&#10;-- We consider any table an array if it has indexes 1..n for its n items, and no&#13;&#10;-- other data in the table.&#13;&#10;-- I think this method is currently a little 'flaky', but can't think of a good way around it yet...&#13;&#10;-- @param t The table to evaluate as an array&#13;&#10;-- @return boolean, number True if the table can be represented as an array, false otherwise. If true,&#13;&#10;-- the second returned value is the maximum&#13;&#10;-- number of indexed elements in the array. &#13;&#10;function isArray(t)&#13;&#10;  -- Next we count all the elements, ensuring that any non-indexed elements are not-encodable &#13;&#10;  -- (with the possible exception of 'n')&#13;&#10;  local maxIndex = 0&#13;&#10;  for k,v in base.pairs(t) do&#13;&#10;    if (base.type(k)=='number' and math.floor(k)==k and 1&lt;=k) then&#9;-- k,v is an indexed pair&#13;&#10;      if (not isEncodable(v)) then return false end&#9;-- All array elements must be encodable&#13;&#10;      maxIndex = math.max(maxIndex,k)&#13;&#10;    else&#13;&#10;      if (k=='n') then&#13;&#10;        if v ~= table.getn(t) then return false end  -- False if n does not hold the number of elements&#13;&#10;      else -- Else of (k=='n')&#13;&#10;        if isEncodable(v) then return false end&#13;&#10;      end  -- End of (k~='n')&#13;&#10;    end -- End of k,v not an indexed pair&#13;&#10;  end  -- End of loop across all pairs&#13;&#10;  return true, maxIndex&#13;&#10;end&#13;&#10;&#13;&#10;--- Determines whether the given Lua object / table / variable can be JSON encoded. The only&#13;&#10;-- types that are JSON encodable are: string, boolean, number, nil, table and json.null.&#13;&#10;-- In this implementation, all other types are ignored.&#13;&#10;-- @param o The object to examine.&#13;&#10;-- @return boolean True if the object should be JSON encoded, false if it should be ignored.&#13;&#10;function isEncodable(o)&#13;&#10;  local t = base.type(o)&#13;&#10;  return (t=='string' or t=='boolean' or t=='number' or t=='nil' or t=='table') or (t=='function' and o==null) &#13;&#10;end"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="00000000000000000000000000000004"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="debugger.lua" luaMethodCode="--{{{  history&#13;&#10;&#13;&#10;--15/03/06 DCN Created based on RemDebug&#13;&#10;--28/04/06 DCN Update for Lua 5.1&#13;&#10;--01/06/06 DCN Fix command argument parsing&#13;&#10;--             Add step/over N facility&#13;&#10;--             Add trace lines facility&#13;&#10;--05/06/06 DCN Add trace call/return facility&#13;&#10;--06/06/06 DCN Make it behave when stepping through the creation of a coroutine&#13;&#10;--06/06/06 DCN Integrate the simple debugger into the main one&#13;&#10;--07/06/06 DCN Provide facility to step into coroutines&#13;&#10;--13/06/06 DCN Fix bug that caused the function environment to get corrupted with the global one&#13;&#10;--14/06/06 DCN Allow 'sloppy' file names when setting breakpoints&#13;&#10;--04/08/06 DCN Allow for no space after command name&#13;&#10;--11/08/06 DCN Use io.write not print&#13;&#10;--30/08/06 DCN Allow access to array elements in 'dump'&#13;&#10;--10/10/06 DCN Default to breakfile for all commands that require a filename and give '-'&#13;&#10;--06/12/06 DCN Allow for punctuation characters in DUMP variable names&#13;&#10;--03/01/07 DCN Add pause on/off facility&#13;&#10;--19/06/07 DCN Allow for duff commands being typed in the debugger (thanks to Michael.Bringmann@lsi.com)&#13;&#10;--             Allow for case sensitive file systems               (thanks to Michael.Bringmann@lsi.com)&#13;&#10;--04/08/09 DCN Add optional line count param to pause&#13;&#10;--05/08/09 DCN Reset the debug hook in Pause() even if we think we're started&#13;&#10;--30/09/09 DCN Re-jig to not use co-routines (makes debugging co-routines awkward)&#13;&#10;--01/10/09 DCN Add ability to break on reaching any line in a file&#13;&#10;--24/07/13 TWW Added code for emulating setfenv/getfenv in Lua 5.2 as per&#13;&#10;--             http://lua-users.org/lists/lua-l/2010-06/msg00313.html&#13;&#10;--25/07/13 TWW Copied Alex Parrill's fix for errors when tracing back across a C frame&#13;&#10;--             (https://github.com/ColonelThirtyTwo/clidebugger, 26/01/12)&#13;&#10;--25/07/13 DCN Allow for windows and unix file name conventions in has_breakpoint&#13;&#10;--26/07/13 DCN Allow for \ being interpreted as an escape inside a [] pattern in 5.2&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  description&#13;&#10;&#13;&#10;--A simple command line debug system for Lua written by Dave Nichols of&#13;&#10;--Match-IT Limited. Its public domain software. Do with it as you wish.&#13;&#10;&#13;&#10;--This debugger was inspired by:&#13;&#10;-- RemDebug 1.0 Beta&#13;&#10;-- Copyright Kepler Project 2005 (http://www.keplerproject.org/remdebug)&#13;&#10;&#13;&#10;--Usage:&#13;&#10;--  require('debugger')        --load the debug library&#13;&#10;--  pause(message)             --start/resume a debug session&#13;&#10;&#13;&#10;--An assert() failure will also invoke the debugger.&#13;&#10;&#13;&#10;--}}}&#13;&#10;&#13;&#10;local IsWindows = string.find(string.lower(os.getenv('OS') or ''),'&#94;windows')&#13;&#10;&#13;&#10;local coro_debugger&#13;&#10;local events = { BREAK = 1, WATCH = 2, STEP = 3, SET = 4 }&#13;&#10;breakpoints = {}&#13;&#10;local watches = {}&#13;&#10;local step_into   = false&#13;&#10;local step_over   = false&#13;&#10;local step_lines  = 0&#13;&#10;local step_level  = {main=0}&#13;&#10;local stack_level = {main=0}&#13;&#10;local trace_level = {main=0}&#13;&#10;local trace_calls = false&#13;&#10;local trace_returns = false&#13;&#10;local trace_lines = false&#13;&#10;local ret_file, ret_line, ret_name&#13;&#10;local current_thread = 'main'&#13;&#10;local started = false&#13;&#10;local pause_off = false&#13;&#10;local _g      = _G&#13;&#10;local cocreate, cowrap = coroutine.create, coroutine.wrap&#13;&#10;local pausemsg = 'pause'&#13;&#10;&#13;&#10;--{{{  make Lua 5.2 compatible&#13;&#10;&#13;&#10;if not setfenv then -- Lua 5.2&#13;&#10;  --[[&#13;&#10;  As far as I can see, the only missing detail of these functions (except&#13;&#10;  for occasional bugs) to achieve 100% compatibility is the case of&#13;&#10;  'getfenv' over a function that does not have an _ENV variable (that is,&#13;&#10;  it uses no globals).&#13;&#10;&#13;&#10;  We could use a weak table to keep the environments of these functions&#13;&#10;  when set by setfenv, but that still misses the case of a function&#13;&#10;  without _ENV that was not subjected to setfenv.&#13;&#10;&#13;&#10;  -- Roberto&#13;&#10;  ]]--&#13;&#10;&#13;&#10;  setfenv = setfenv or function(f, t)&#13;&#10;    f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)&#13;&#10;    local name&#13;&#10;    local up = 0&#13;&#10;    repeat&#13;&#10;      up = up + 1&#13;&#10;      name = debug.getupvalue(f, up)&#13;&#10;    until name == '_ENV' or name == nil&#13;&#10;    if name then&#13;&#10;      debug.upvaluejoin(f, up, function() return name end, 1) -- use unique upvalue&#13;&#10;      debug.setupvalue(f, up, t)&#13;&#10;    end&#13;&#10;  end&#13;&#10;&#13;&#10;  getfenv = getfenv or function(f)&#13;&#10;    f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)&#13;&#10;    local name, val&#13;&#10;    local up = 0&#13;&#10;    repeat&#13;&#10;      up = up + 1&#13;&#10;      name, val = debug.getupvalue(f, up)&#13;&#10;    until name == '_ENV' or name == nil&#13;&#10;    return val&#13;&#10;  end&#13;&#10;&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;&#13;&#10;--{{{  local hints -- command help&#13;&#10;--The format in here is name=summary|description&#13;&#10;local hints = {&#13;&#10;&#13;&#10;pause =   [[&#13;&#10;pause(msg[,lines][,force]) -- start/resume a debugger session|&#13;&#10;&#13;&#10;This can only be used in your code or from the console as a means to&#13;&#10;start/resume a debug session.&#13;&#10;If msg is given that is shown when the session starts/resumes. Useful to&#13;&#10;give a context if you've instrumented your code with pause() statements.&#13;&#10;&#13;&#10;If lines is given, the script pauses after that many lines, else it pauses&#13;&#10;immediately.&#13;&#10;&#13;&#10;If force is true, the pause function is honoured even if poff has been used.&#13;&#10;This is useful when in an interactive console session to regain debugger&#13;&#10;control.&#13;&#10;]],&#13;&#10;&#13;&#10;poff =    [[&#13;&#10;poff                -- turn off pause() command|&#13;&#10;&#13;&#10;This causes all pause() commands to be ignored. This is useful if you have&#13;&#10;instrumented your code in a busy loop and want to continue normal execution&#13;&#10;with no further interruption.&#13;&#10;]],&#13;&#10;&#13;&#10;pon =     [[&#13;&#10;pon                 -- turn on pause() command|&#13;&#10;&#13;&#10;This re-instates honouring the pause() commands you may have instrumented&#13;&#10;your code with.&#13;&#10;]],&#13;&#10;&#13;&#10;setb =    [[&#13;&#10;setb [line file]    -- set a breakpoint to line/file|, line 0 means 'any'&#13;&#10;&#13;&#10;If file is omitted or is &quot;-&quot; the breakpoint is set at the file for the&#13;&#10;currently set level (see &quot;set&quot;). Execution pauses when this line is about&#13;&#10;to be executed and the debugger session is re-activated.&#13;&#10;&#13;&#10;The file can be given as the fully qualified name, partially qualified or&#13;&#10;just the file name. E.g. if file is set as &quot;myfile.lua&quot;, then whenever&#13;&#10;execution reaches any file that ends with &quot;myfile.lua&quot; it will pause. If&#13;&#10;no extension is given, any extension will do.&#13;&#10;&#13;&#10;If the line is given as 0, then reaching any line in the file will do.&#13;&#10;]],&#13;&#10;&#13;&#10;delb =    [[&#13;&#10;delb [line file]    -- removes a breakpoint|&#13;&#10;&#13;&#10;If file is omitted or is &quot;-&quot; the breakpoint is removed for the file of the&#13;&#10;currently set level (see &quot;set&quot;).&#13;&#10;]],&#13;&#10;&#13;&#10;delallb = [[&#13;&#10;delallb             -- removes all breakpoints|&#13;&#10;]],&#13;&#10;&#13;&#10;setw =    [[&#13;&#10;setw &lt;exp&gt;          -- adds a new watch expression|&#13;&#10;&#13;&#10;The expression is evaluated before each line is executed. If the expression&#13;&#10;yields true then execution is paused and the debugger session re-activated.&#13;&#10;The expression is executed in the context of the line about to be executed.&#13;&#10;]],&#13;&#10;&#13;&#10;delw =    [[&#13;&#10;delw &lt;index&gt;        -- removes the watch expression at index|&#13;&#10;&#13;&#10;The index is that returned when the watch expression was set by setw.&#13;&#10;]],&#13;&#10;&#13;&#10;delallw = [[&#13;&#10;delallw             -- removes all watch expressions|&#13;&#10;]],&#13;&#10;&#13;&#10;run     = [[&#13;&#10;run                 -- run until next breakpoint or watch expression|&#13;&#10;]],&#13;&#10;&#13;&#10;step    = [[&#13;&#10;step [N]            -- run next N lines, stepping into function calls|&#13;&#10;&#13;&#10;If N is omitted, use 1.&#13;&#10;]],&#13;&#10;&#13;&#10;over    = [[&#13;&#10;over [N]            -- run next N lines, stepping over function calls|&#13;&#10;&#13;&#10;If N is omitted, use 1.&#13;&#10;]],&#13;&#10;&#13;&#10;out     = [[&#13;&#10;out [N]             -- run lines until stepped out of N functions|&#13;&#10;&#13;&#10;If N is omitted, use 1.&#13;&#10;If you are inside a function, using &quot;out 1&quot; will run until you return&#13;&#10;from that function to the caller.&#13;&#10;]],&#13;&#10;&#13;&#10;gotoo   = [[&#13;&#10;gotoo [line file]    -- step to line in file|&#13;&#10;&#13;&#10;This is equivalent to 'setb line file', followed by 'run', followed&#13;&#10;by 'delb line file'.&#13;&#10;]],&#13;&#10;&#13;&#10;listb   = [[&#13;&#10;listb               -- lists breakpoints|&#13;&#10;]],&#13;&#10;&#13;&#10;listw   = [[&#13;&#10;listw               -- lists watch expressions|&#13;&#10;]],&#13;&#10;&#13;&#10;set     = [[&#13;&#10;set [level]         -- set context to stack level, omitted=show|&#13;&#10;&#13;&#10;If level is omitted it just prints the current level set.&#13;&#10;This sets the current context to the level given. This affects the&#13;&#10;context used for several other functions (e.g. vars). The possible&#13;&#10;levels are those shown by trace.&#13;&#10;]],&#13;&#10;&#13;&#10;vars    = [[&#13;&#10;vars [depth]        -- list context locals to depth, omitted=1|&#13;&#10;&#13;&#10;If depth is omitted then uses 1.&#13;&#10;Use a depth of 0 for the maximum.&#13;&#10;Lists all non-nil local variables and all non-nil upvalues in the&#13;&#10;currently set context. For variables that are tables, lists all fields&#13;&#10;to the given depth.&#13;&#10;]],&#13;&#10;&#13;&#10;fenv    = [[&#13;&#10;fenv [depth]        -- list context function env to depth, omitted=1|&#13;&#10;&#13;&#10;If depth is omitted then uses 1.&#13;&#10;Use a depth of 0 for the maximum.&#13;&#10;Lists all function environment variables in the currently set context.&#13;&#10;For variables that are tables, lists all fields to the given depth.&#13;&#10;]],&#13;&#10;&#13;&#10;glob    = [[&#13;&#10;glob [depth]        -- list globals to depth, omitted=1|&#13;&#10;&#13;&#10;If depth is omitted then uses 1.&#13;&#10;Use a depth of 0 for the maximum.&#13;&#10;Lists all global variables.&#13;&#10;For variables that are tables, lists all fields to the given depth.&#13;&#10;]],&#13;&#10;&#13;&#10;ups     = [[&#13;&#10;ups                 -- list all the upvalue names|&#13;&#10;&#13;&#10;These names will also be in the &quot;vars&quot; list unless their value is nil.&#13;&#10;This provides a means to identify which vars are upvalues and which are&#13;&#10;locals. If a name is both an upvalue and a local, the local value takes&#13;&#10;precedance.&#13;&#10;]],&#13;&#10;&#13;&#10;locs    = [[&#13;&#10;locs                -- list all the locals names|&#13;&#10;&#13;&#10;These names will also be in the &quot;vars&quot; list unless their value is nil.&#13;&#10;This provides a means to identify which vars are upvalues and which are&#13;&#10;locals. If a name is both an upvalue and a local, the local value takes&#13;&#10;precedance.&#13;&#10;]],&#13;&#10;&#13;&#10;dump    = [[&#13;&#10;dump &lt;var&gt; [depth]  -- dump all fields of variable to depth|&#13;&#10;&#13;&#10;If depth is omitted then uses 1.&#13;&#10;Use a depth of 0 for the maximum.&#13;&#10;Prints the value of &lt;var&gt; in the currently set context level. If &lt;var&gt;&#13;&#10;is a table, lists all fields to the given depth. &lt;var&gt; can be just a&#13;&#10;name, or name.field or name.# to any depth, e.g. t.1.f accesses field&#13;&#10;'f' in array element 1 in table 't'.&#13;&#10;&#13;&#10;Can also be called from a script as dump(var,depth).&#13;&#10;]],&#13;&#10;&#13;&#10;tron    = [[&#13;&#10;tron [crl]          -- turn trace on for (c)alls, (r)etuns, (l)lines|&#13;&#10;&#13;&#10;If no parameter is given then tracing is turned off.&#13;&#10;When tracing is turned on a line is printed to the console for each&#13;&#10;debug 'event' selected. c=function calls, r=function returns, l=lines.&#13;&#10;]],&#13;&#10;&#13;&#10;trace   = [[&#13;&#10;trace               -- dumps a stack trace|&#13;&#10;&#13;&#10;Format is [level] = file,line,name&#13;&#10;The level is a candidate for use by the 'set' command.&#13;&#10;]],&#13;&#10;&#13;&#10;info    = [[&#13;&#10;info                -- dumps the complete debug info captured|&#13;&#10;&#13;&#10;Only useful as a diagnostic aid for the debugger itself. This information&#13;&#10;can be HUGE as it dumps all variables to the maximum depth, so be careful.&#13;&#10;]],&#13;&#10;&#13;&#10;show    = [[&#13;&#10;show line file X Y  -- show X lines before and Y after line in file|&#13;&#10;&#13;&#10;If line is omitted or is '-' then the current set context line is used.&#13;&#10;If file is omitted or is '-' then the current set context file is used.&#13;&#10;If file is not fully qualified and cannot be opened as specified, then&#13;&#10;a search for the file in the package[path] is performed using the usual&#13;&#10;&quot;require&quot; searching rules. If no file extension is given, .lua is used.&#13;&#10;Prints the lines from the source file around the given line.&#13;&#10;]],&#13;&#10;&#13;&#10;exit    = [[&#13;&#10;exit                -- exits debugger, re-start it using pause()|&#13;&#10;]],&#13;&#10;&#13;&#10;help    = [[&#13;&#10;help [command]      -- show this list or help for command|&#13;&#10;]],&#13;&#10;&#13;&#10;[&quot;&lt;statement&gt;&quot;] = [[&#13;&#10;&lt;statement&gt;         -- execute a statement in the current context|&#13;&#10;&#13;&#10;The statement can be anything that is legal in the context, including&#13;&#10;assignments. Such assignments affect the context and will be in force&#13;&#10;immediately. Any results returned are printed. Use '=' as a short-hand&#13;&#10;for 'return', e.g. &quot;=func(arg)&quot; will call 'func' with 'arg' and print&#13;&#10;the results, and &quot;=var&quot; will just print the value of 'var'.&#13;&#10;]],&#13;&#10;&#13;&#10;what    = [[&#13;&#10;what &lt;func&gt;         -- show where &lt;func&gt; is defined (if known)|&#13;&#10;]],&#13;&#10;&#13;&#10;}&#13;&#10;--}}}&#13;&#10;&#13;&#10;--{{{ Local function to get table size&#13;&#10;local function tsize(t)&#13;&#10;    local count=0&#13;&#10;&#13;&#10;    for k,v in pairs(t) do&#13;&#10;        count = count + 1&#13;&#10;    end&#13;&#10;&#13;&#10;    return count&#13;&#10;end&#13;&#10;---}}}&#13;&#10;&#13;&#10;---{{{ Global utility function to set breakpoints, used inside Ctrlr&#13;&#10;function setBreakpoint(line, file, shouldBeSet)&#13;&#10;    if not breakpoints[line] then&#13;&#10;        breakpoints[line] = {}&#13;&#10;    end&#13;&#10;&#13;&#10;    if shouldBeSet then&#13;&#10;        breakpoints[line][file] = true&#13;&#10;    else&#13;&#10;        breakpoints[line] = nil&#13;&#10;    end&#13;&#10;end&#13;&#10;---}}}&#13;&#10;&#13;&#10;&#13;&#10;--{{{  local function getinfo(level,field)&#13;&#10;&#13;&#10;--like debug.getinfo but copes with no activation record at the given level&#13;&#10;--and knows how to get 'field'. 'field' can be the name of any of the&#13;&#10;--activation record fields or any of the 'what' names or nil for everything.&#13;&#10;--only valid when using the stack level to get info, not a function name.&#13;&#10;&#13;&#10;local function getinfo(level,field)&#13;&#10;  level = level + 1  --to get to the same relative level as the caller&#13;&#10;  if not field then return debug.getinfo(level) end&#13;&#10;  local what&#13;&#10;  if field == 'name' or field == 'namewhat' then&#13;&#10;    what = 'n'&#13;&#10;  elseif field == 'what' or field == 'source' or field == 'linedefined' or field == 'lastlinedefined' or field == 'short_src' then&#13;&#10;    what = 'S'&#13;&#10;  elseif field == 'currentline' then&#13;&#10;    what = 'l'&#13;&#10;  elseif field == 'nups' then&#13;&#10;    what = 'u'&#13;&#10;  elseif field == 'func' then&#13;&#10;    what = 'f'&#13;&#10;  else&#13;&#10;    return debug.getinfo(level,field)&#13;&#10;  end&#13;&#10;  local ar = debug.getinfo(level,what)&#13;&#10;  if ar then return ar[field] else return nil end&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function indented( level, ... )&#13;&#10;&#13;&#10;local function indented( level, ... )&#13;&#10;  ctrlrDebugger:write( string.format (&quot;%s%s\n&quot;, string.rep('  ',level), table.concat({...}) ))&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function dumpval( level, name, value, limit )&#13;&#10;&#13;&#10;local dumpvisited&#13;&#10;&#13;&#10;local function dumpval( level, name, value, limit )&#13;&#10;    local index&#13;&#10;&#13;&#10;    if type(name) == 'number' then&#13;&#10;        index = string.format(&quot;%q,&quot;,name)&#13;&#10;    elseif type(name) == 'string' and (name == '__VARSLEVEL__' or name == '__ENVIRONMENT__' or name == '__GLOBALS__' or name == '__UPVALUES__' or name == '__LOCALS__') then&#13;&#10;        --ignore these, they are debugger generated&#13;&#10;        return&#13;&#10;    elseif type(name) == 'string' and string.find(name,'&#94;[_%a][_.%w]*$') then&#13;&#10;        index = string.format (&quot;%q: &quot;, name);&#13;&#10;    else&#13;&#10;        index = string.format (&quot;%q,&quot;, tostring(name))&#13;&#10;    end&#13;&#10;&#13;&#10;    if type(value) == 'table' then&#13;&#10;        if dumpvisited[value] then&#13;&#10;            indented (level, index, string.format(&quot;%q&quot;, dumpvisited[value]))&#13;&#10;        else&#13;&#10;            dumpvisited[value] = string.format (&quot;\&quot;table\&quot;: \&quot;%d\&quot;,&quot;, tsize (value))&#13;&#10;            if (limit or 0) &gt; 0 and level+1 &gt;= limit then&#13;&#10;                indented (level, index, string.format (&quot;{%s&quot;, string.gsub(dumpvisited[value], &quot;,&quot;, &quot;},&quot;)))&#13;&#10;            else&#13;&#10;                indented (level, index, &quot;{\n&quot;, dumpvisited[value])&#13;&#10;&#13;&#10;                for n,v in pairs(value) do&#13;&#10;                    dumpval (level+1, n, v, limit)&#13;&#10;                end&#13;&#10;&#13;&#10;                indented (level, &quot;}&quot;)&#13;&#10;            end&#13;&#10;        end&#13;&#10;    else&#13;&#10;        if type(value) == 'string' then&#13;&#10;            indented (level, index, string.format(&quot;{\&quot;string\&quot;: %q}&quot;,value), ',')&#13;&#10;        end&#13;&#10;&#13;&#10;        if type(value) == 'userdata' then&#13;&#10;            info = class_info (value)&#13;&#10;            indented (level, index, string.format (&quot;{\&quot;userdata\&quot;: %q}&quot;, info.name) , ',')&#13;&#10;        end&#13;&#10;&#13;&#10;        if type(value) == 'number' then&#13;&#10;            indented (level, index, string.format (&quot;{\&quot;number\&quot;: %q}&quot;,tostring(value)), ',')&#13;&#10;        end&#13;&#10;    end&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function dumpvar( value, limit, name )&#13;&#10;&#13;&#10;local function dumpvar( value, limit, name )&#13;&#10;  ctrlrDebugger:write (&quot;\n::start dumpvar\n&quot;)&#13;&#10;  dumpvisited = {}&#13;&#10;  dumpval( 0, name or tostring(value), value, limit )&#13;&#10;  ctrlrDebugger:write (&quot;::end\n&quot;)&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function show(file,line,before,after)&#13;&#10;&#13;&#10;--show +/-N lines of a file around line M&#13;&#10;&#13;&#10;local function show(file,line,before,after)&#13;&#10;&#13;&#10;  line   = tonumber(line   or 1)&#13;&#10;  before = tonumber(before or 10)&#13;&#10;  after  = tonumber(after  or before)&#13;&#10;&#13;&#10;  if not string.find(file,'%.') then file = file..'.lua' end&#13;&#10;&#13;&#10;  local f = io.open(file,'r')&#13;&#10;  if not f then&#13;&#10;    --{{{  try to find the file in the path&#13;&#10;&#13;&#10;    --&#13;&#10;    -- looks for a file in the package path&#13;&#10;    --&#13;&#10;    local path = package.path or LUA_PATH or ''&#13;&#10;    for c in string.gmatch (path, &quot;[&#94;;]+&quot;) do&#13;&#10;      local c = string.gsub (c, &quot;%?%.lua&quot;, file)&#13;&#10;      f = io.open (c,'r')&#13;&#10;      if f then&#13;&#10;        break&#13;&#10;      end&#13;&#10;    end&#13;&#10;&#13;&#10;    --}}}&#13;&#10;    if not f then&#13;&#10;      ctrlrDebugger:write('Cannot find '..file..'\n')&#13;&#10;      return&#13;&#10;    end&#13;&#10;  end&#13;&#10;&#13;&#10;  local i = 0&#13;&#10;  for l in f:lines() do&#13;&#10;    i = i + 1&#13;&#10;    if i &gt;= (line-before) then&#13;&#10;      if i &gt; (line+after) then break end&#13;&#10;      if i == line then&#13;&#10;        ctrlrDebugger:write(i..'***\t'..l..'\n')&#13;&#10;      else&#13;&#10;        ctrlrDebugger:write(i..'\t'..l..'\n')&#13;&#10;      end&#13;&#10;    end&#13;&#10;  end&#13;&#10;&#13;&#10;  f:close()&#13;&#10;&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function tracestack(l)&#13;&#10;&#13;&#10;local function gi( i )&#13;&#10;  return function() i=i+1 return debug.getinfo(i),i end&#13;&#10;end&#13;&#10;&#13;&#10;local function gl( level, j )&#13;&#10;  return function() j=j+1 return debug.getlocal( level, j ) end&#13;&#10;end&#13;&#10;&#13;&#10;local function gu( func, k )&#13;&#10;  return function() k=k+1 return debug.getupvalue( func, k ) end&#13;&#10;end&#13;&#10;&#13;&#10;local  traceinfo&#13;&#10;&#13;&#10;local function tracestack(l)&#13;&#10;  local l = l + 1                        --NB: +1 to get level relative to caller&#13;&#10;  traceinfo = {}&#13;&#10;  traceinfo.pausemsg = pausemsg&#13;&#10;  for ar,i in gi(l) do&#13;&#10;    table.insert( traceinfo, ar )&#13;&#10;    if ar.what ~= 'C' then&#13;&#10;      local names  = {}&#13;&#10;      local values = {}&#13;&#10;      for n,v in gl(i,0) do&#13;&#10;        if string.sub(n,1,1) ~= '(' then   --ignore internal control variables&#13;&#10;          table.insert( names, n )&#13;&#10;          table.insert( values, v )&#13;&#10;        end&#13;&#10;      end&#13;&#10;      if #names &gt; 0 then&#13;&#10;        ar.lnames  = names&#13;&#10;        ar.lvalues = values&#13;&#10;      end&#13;&#10;    end&#13;&#10;    if ar.func then&#13;&#10;      local names  = {}&#13;&#10;      local values = {}&#13;&#10;      for n,v in gu(ar.func,0) do&#13;&#10;        if string.sub(n,1,1) ~= '(' then   --ignore internal control variables&#13;&#10;          table.insert( names, n )&#13;&#10;          table.insert( values, v )&#13;&#10;        end&#13;&#10;      end&#13;&#10;      if #names &gt; 0 then&#13;&#10;        ar.unames  = names&#13;&#10;        ar.uvalues = values&#13;&#10;      end&#13;&#10;    end&#13;&#10;  end&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function trace()&#13;&#10;&#13;&#10;local function trace(set)&#13;&#10;  ctrlrDebugger:write (&quot;\n::start trace\n&quot;)&#13;&#10;  local mark&#13;&#10;  for level,ar in ipairs(traceinfo) do&#13;&#10;    if level == set then&#13;&#10;      mark = '***'&#13;&#10;    else&#13;&#10;      mark = ''&#13;&#10;    end&#13;&#10;    ctrlrDebugger:write('['..level..']'..mark..'\t'..(ar.name or ar.what)..' in '..ar.short_src..':'..ar.currentline..'\n')&#13;&#10;  end&#13;&#10;&#13;&#10;  ctrlrDebugger:write (&quot;::end\n&quot;)&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function info()&#13;&#10;&#13;&#10;local function info()&#13;&#10;    dumpvar( traceinfo, 0, 'traceinfo' )&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;&#13;&#10;--{{{  local function set_breakpoint(file, line, once)&#13;&#10;&#13;&#10;local function set_breakpoint(file, line, once)&#13;&#10;  if not breakpoints[line] then&#13;&#10;    breakpoints[line] = {}&#13;&#10;  end&#13;&#10;  if once then&#13;&#10;    breakpoints[line][file] = 1&#13;&#10;  else&#13;&#10;    breakpoints[line][file] = true&#13;&#10;  end&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function remove_breakpoint(file, line)&#13;&#10;&#13;&#10;local function remove_breakpoint(file, line)&#13;&#10;  if breakpoints[line] then&#13;&#10;    breakpoints[line][file] = nil&#13;&#10;  end&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function has_breakpoint(file, line)&#13;&#10;&#13;&#10;--allow for 'sloppy' file names&#13;&#10;--search for file and all variations walking up its directory hierachy&#13;&#10;--ditto for the file with no extension&#13;&#10;--a breakpoint can be permenant or once only, if once only its removed&#13;&#10;--after detection here, these are used for temporary breakpoints in the&#13;&#10;--debugger loop when executing the 'gotoo' command&#13;&#10;--a breakpoint on line 0 of a file means any line in that file&#13;&#10;&#13;&#10;local function has_breakpoint(file, line)&#13;&#10;  local isLine = breakpoints[line]&#13;&#10;  local isZero = breakpoints[0]&#13;&#10;  if not isLine and not isZero then return false end&#13;&#10;  local noext = string.gsub(file,&quot;(%..-)$&quot;,'',1)&#13;&#10;  if noext == file then noext = nil end&#13;&#10;  while file do&#13;&#10;    if isLine and isLine[file] then&#13;&#10;      if isLine[file] == 1 then isLine[file] = nil end&#13;&#10;      return true&#13;&#10;    end&#13;&#10;    if isZero and isZero[file] then&#13;&#10;      if isZero[file] == 1 then isZero[file] = nil end&#13;&#10;      return true&#13;&#10;    end&#13;&#10;    if IsWindows then&#13;&#10;      file = string.match(file,&quot;[:/\\](.+)$&quot;)&#13;&#10;    else&#13;&#10;      file = string.match(file,&quot;[:/](.+)$&quot;)&#13;&#10;    end&#13;&#10;  end&#13;&#10;  while noext do&#13;&#10;    if isLine and isLine[noext] then&#13;&#10;      if isLine[noext] == 1 then isLine[noext] = nil end&#13;&#10;      return true&#13;&#10;    end&#13;&#10;    if isZero and isZero[noext] then&#13;&#10;      if isZero[noext] == 1 then isZero[noext] = nil end&#13;&#10;      return true&#13;&#10;    end&#13;&#10;    if IsWindows then&#13;&#10;      noext = string.match(noext,&quot;[:/\\](.+)$&quot;)&#13;&#10;    else&#13;&#10;      noext = string.match(noext,&quot;[:/](.+)$&quot;)&#13;&#10;    end&#13;&#10;  end&#13;&#10;  return false&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function capture_vars(ref,level,line)&#13;&#10;&#13;&#10;local function capture_vars(ref,level,line)&#13;&#10;  --get vars, file and line for the given level relative to debug_hook offset by ref&#13;&#10;&#13;&#10;  local lvl = ref + level                --NB: This includes an offset of +1 for the call to here&#13;&#10;&#13;&#10;  --{{{  capture variables&#13;&#10;&#13;&#10;  local ar = debug.getinfo(lvl, &quot;f&quot;)&#13;&#10;  if not ar then return {},'?',0 end&#13;&#10;&#13;&#10;  local vars = {__UPVALUES__={}, __LOCALS__={}}&#13;&#10;  local i&#13;&#10;&#13;&#10;  local func = ar.func&#13;&#10;  if func then&#13;&#10;    i = 1&#13;&#10;    while true do&#13;&#10;      local name, value = debug.getupvalue(func, i)&#13;&#10;      if not name then break end&#13;&#10;      if string.sub(name,1,1) ~= '(' then  --NB: ignoring internal control variables&#13;&#10;        vars[name] = value&#13;&#10;        vars.__UPVALUES__[i] = name&#13;&#10;      end&#13;&#10;      i = i + 1&#13;&#10;    end&#13;&#10;    vars.__ENVIRONMENT__ = getfenv(func)&#13;&#10;  end&#13;&#10;&#13;&#10;  vars.__GLOBALS__ = getfenv(0)&#13;&#10;&#13;&#10;  i = 1&#13;&#10;  while true do&#13;&#10;    local name, value = debug.getlocal(lvl, i)&#13;&#10;    if not name then break end&#13;&#10;    if string.sub(name,1,1) ~= '(' then    --NB: ignoring internal control variables&#13;&#10;      vars[name] = value&#13;&#10;      vars.__LOCALS__[i] = name&#13;&#10;    end&#13;&#10;    i = i + 1&#13;&#10;  end&#13;&#10;&#13;&#10;  vars.__VARSLEVEL__ = level&#13;&#10;&#13;&#10;  if func then&#13;&#10;    --NB: Do not do this until finished filling the vars table&#13;&#10;    setmetatable(vars, { __index = getfenv(func), __newindex = getfenv(func) })&#13;&#10;  end&#13;&#10;&#13;&#10;  --NB: Do not read or write the vars table anymore else the metatable functions will get invoked!&#13;&#10;&#13;&#10;  --}}}&#13;&#10;&#13;&#10;  local file = getinfo(lvl, &quot;source&quot;)&#13;&#10;  if string.find(file, &quot;@&quot;) == 1 then&#13;&#10;    file = string.sub(file, 2)&#13;&#10;  end&#13;&#10;  if IsWindows then file = string.lower(file) end&#13;&#10;&#13;&#10;  if not line then&#13;&#10;    line = getinfo(lvl, &quot;currentline&quot;)&#13;&#10;  end&#13;&#10;&#13;&#10;  return vars,file,line&#13;&#10;&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function restore_vars(ref,vars)&#13;&#10;&#13;&#10;local function restore_vars(ref,vars)&#13;&#10;&#13;&#10;  if type(vars) ~= 'table' then return end&#13;&#10;&#13;&#10;  local level = vars.__VARSLEVEL__       --NB: This level is relative to debug_hook offset by ref&#13;&#10;  if not level then return end&#13;&#10;&#13;&#10;  level = level + ref                    --NB: This includes an offset of +1 for the call to here&#13;&#10;&#13;&#10;  local i&#13;&#10;  local written_vars = {}&#13;&#10;&#13;&#10;  i = 1&#13;&#10;  while true do&#13;&#10;    local name, value = debug.getlocal(level, i)&#13;&#10;    if not name then break end&#13;&#10;    if vars[name] and string.sub(name,1,1) ~= '(' then     --NB: ignoring internal control variables&#13;&#10;      debug.setlocal(level, i, vars[name])&#13;&#10;      written_vars[name] = true&#13;&#10;    end&#13;&#10;    i = i + 1&#13;&#10;  end&#13;&#10;&#13;&#10;  local ar = debug.getinfo(level, &quot;f&quot;)&#13;&#10;  if not ar then return end&#13;&#10;&#13;&#10;  local func = ar.func&#13;&#10;  if func then&#13;&#10;&#13;&#10;    i = 1&#13;&#10;    while true do&#13;&#10;      local name, value = debug.getupvalue(func, i)&#13;&#10;      if not name then break end&#13;&#10;      if vars[name] and string.sub(name,1,1) ~= '(' then   --NB: ignoring internal control variables&#13;&#10;        if not written_vars[name] then&#13;&#10;          debug.setupvalue(func, i, vars[name])&#13;&#10;        end&#13;&#10;        written_vars[name] = true&#13;&#10;      end&#13;&#10;      i = i + 1&#13;&#10;    end&#13;&#10;&#13;&#10;  end&#13;&#10;&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function trace_event(event, line, level)&#13;&#10;&#13;&#10;local function print_trace(level,depth,event,file,line,name)&#13;&#10;&#13;&#10;  --NB: level here is relative to the caller of trace_event, so offset by 2 to get to there&#13;&#10;  level = level + 2&#13;&#10;&#13;&#10;  local file = file or getinfo(level,'short_src')&#13;&#10;  local line = line or getinfo(level,'currentline')&#13;&#10;  local name = name or getinfo(level,'name')&#13;&#10;&#13;&#10;  local prefix = ''&#13;&#10;  if current_thread ~= 'main' then prefix = '['..tostring(current_thread)..'] ' end&#13;&#10;&#13;&#10;  ctrlrDebugger:write(prefix..&#13;&#10;           string.format('%08.2f:%02i.',os.clock(),depth)..&#13;&#10;           string.rep('.',depth%32)..&#13;&#10;           (file or '')..' ('..(line or '')..') '..&#13;&#10;           (name or '')..&#13;&#10;           ' ('..event..')\n')&#13;&#10;&#13;&#10;end&#13;&#10;&#13;&#10;local function trace_event(event, line, level)&#13;&#10;&#13;&#10;  if event == 'return' and trace_returns then&#13;&#10;    --note the line info for later&#13;&#10;    ret_file = getinfo(level+1,'short_src')&#13;&#10;    ret_line = getinfo(level+1,'currentline')&#13;&#10;    ret_name = getinfo(level+1,'name')&#13;&#10;  end&#13;&#10;&#13;&#10;  if event ~= 'line' then return end&#13;&#10;&#13;&#10;  local slevel = stack_level[current_thread]&#13;&#10;  local tlevel = trace_level[current_thread]&#13;&#10;&#13;&#10;  if trace_calls and slevel &gt; tlevel then&#13;&#10;    --we are now in the function called, so look back 1 level further to find the calling file and line&#13;&#10;    print_trace(level+1,slevel-1,'c',nil,nil,getinfo(level+1,'name'))&#13;&#10;  end&#13;&#10;&#13;&#10;  if trace_returns and slevel &lt; tlevel then&#13;&#10;    print_trace(level,slevel,'r',ret_file,ret_line,ret_name)&#13;&#10;  end&#13;&#10;&#13;&#10;  if trace_lines then&#13;&#10;    print_trace(level,slevel,'l')&#13;&#10;  end&#13;&#10;&#13;&#10;  trace_level[current_thread] = stack_level[current_thread]&#13;&#10;&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function report(ev, vars, file, line, idx_watch)&#13;&#10;&#13;&#10;local function report(ev, vars, file, line, idx_watch)&#13;&#10;  local vars = vars or {}&#13;&#10;  local file = file or '?'&#13;&#10;  local line = line or 0&#13;&#10;  local prefix = ''&#13;&#10;  if current_thread ~= 'main' then prefix = '['..tostring(current_thread)..'] ' end&#13;&#10;  if ev == events.STEP then&#13;&#10;    ctrlrDebugger:write(prefix..&quot;Paused at file &quot;..file..&quot; line &quot;..line..' ('..stack_level[current_thread]..')\n')&#13;&#10;  elseif ev == events.BREAK then&#13;&#10;    ctrlrDebugger:write(prefix..&quot;Paused at file &quot;..file..&quot; line &quot;..line..' ('..stack_level[current_thread]..') (breakpoint)\n')&#13;&#10;  elseif ev == events.WATCH then&#13;&#10;    ctrlrDebugger:write(prefix..&quot;Paused at file &quot;..file..&quot; line &quot;..line..' ('..stack_level[current_thread]..')'..&quot; (watch expression &quot;..idx_watch.. &quot;: [&quot;..watches[idx_watch].exp..&quot;])\n&quot;)&#13;&#10;  elseif ev == events.SET then&#13;&#10;    --do nothing&#13;&#10;  else&#13;&#10;    ctrlrDebugger:write(prefix..&quot;Error in application: &quot;..file..&quot; line &quot;..line..&quot;\n&quot;)&#13;&#10;  end&#13;&#10;  if ev ~= events.SET then&#13;&#10;    if pausemsg and pausemsg ~= '' then ctrlrDebugger:write('Message: '..pausemsg..'\n') end&#13;&#10;    pausemsg = ''&#13;&#10;  end&#13;&#10;  return vars, file, line&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;&#13;&#10;--{{{  local function debugger_loop(ev, vars, file, line, idx_watch)&#13;&#10;&#13;&#10;local function debugger_loop(ev, vars, file, line, idx_watch)&#13;&#10;&#13;&#10;  local eval_env  = vars or {}&#13;&#10;  local breakfile = file or '?'&#13;&#10;  local breakline = line or 0&#13;&#10;&#13;&#10;  local command, args&#13;&#10;&#13;&#10;  --{{{  local function getargs(spec)&#13;&#10;&#13;&#10;  --get command arguments according to the given spec from the args string&#13;&#10;  --the spec has a single character for each argument, arguments are separated&#13;&#10;  --by white space, the spec characters can be one of:&#13;&#10;  -- F for a filename    (defaults to breakfile if - given in args)&#13;&#10;  -- L for a line number (defaults to breakline if - given in args)&#13;&#10;  -- N for a number&#13;&#10;  -- V for a variable name&#13;&#10;  -- S for a string&#13;&#10;&#13;&#10;  local function getargs(spec)&#13;&#10;    local res={}&#13;&#10;    local char,arg&#13;&#10;    local ptr=1&#13;&#10;    for i=1,string.len(spec) do&#13;&#10;      char = string.sub(spec,i,i)&#13;&#10;      if     char == 'F' then&#13;&#10;        _,ptr,arg = string.find(args..' ',&quot;%s*([%w%p]*)%s*&quot;,ptr)&#13;&#10;        if not arg or arg == '' then arg = '-' end&#13;&#10;        if arg == '-' then arg = breakfile end&#13;&#10;      elseif char == 'L' then&#13;&#10;        _,ptr,arg = string.find(args..' ',&quot;%s*([%w%p]*)%s*&quot;,ptr)&#13;&#10;        if not arg or arg == '' then arg = '-' end&#13;&#10;        if arg == '-' then arg = breakline end&#13;&#10;        arg = tonumber(arg) or 0&#13;&#10;      elseif char == 'N' then&#13;&#10;        _,ptr,arg = string.find(args..' ',&quot;%s*([%w%p]*)%s*&quot;,ptr)&#13;&#10;        if not arg or arg == '' then arg = '0' end&#13;&#10;        arg = tonumber(arg) or 0&#13;&#10;      elseif char == 'V' then&#13;&#10;        _,ptr,arg = string.find(args..' ',&quot;%s*([%w%p]*)%s*&quot;,ptr)&#13;&#10;        if not arg or arg == '' then arg = '' end&#13;&#10;      elseif char == 'S' then&#13;&#10;        _,ptr,arg = string.find(args..' ',&quot;%s*([%w%p]*)%s*&quot;,ptr)&#13;&#10;        if not arg or arg == '' then arg = '' end&#13;&#10;      else&#13;&#10;        arg = ''&#13;&#10;      end&#13;&#10;      table.insert(res,arg or '')&#13;&#10;    end&#13;&#10;    return unpack(res)&#13;&#10;  end&#13;&#10;&#13;&#10;  --}}}&#13;&#10;&#13;&#10;  while true do&#13;&#10;    -- io.write(&quot;[DEBUG]&gt; &quot;)&#13;&#10;    ctrlrDebugger:write(&quot;[DEBUG]&gt; &quot;)&#13;&#10;    -- local line = io.read(&quot;*line&quot;)&#13;&#10;    local line = ctrlrDebugger:read()&#13;&#10;    if line == nil then ctrlrDebugger:write('\n'); line = 'exit' end&#13;&#10;&#13;&#10;    if string.find(line, &quot;&#94;[a-z]+&quot;) then&#13;&#10;      command = string.sub(line, string.find(line, &quot;&#94;[a-z]+&quot;))&#13;&#10;      args    = string.gsub(line,&quot;&#94;[a-z]+%s*&quot;,'',1)            --strip command off line&#13;&#10;    else&#13;&#10;      command = ''&#13;&#10;    end&#13;&#10;&#13;&#10;    if command == &quot;setb&quot; then&#13;&#10;      --{{{  set breakpoint&#13;&#10;&#13;&#10;      local line, filename  = getargs('LF')&#13;&#10;      if filename ~= '' and line ~= '' then&#13;&#10;        set_breakpoint(filename,line)&#13;&#10;        ctrlrDebugger:write(&quot;Breakpoint set in file &quot;..filename..' line '..line..'\n')&#13;&#10;      else&#13;&#10;        ctrlrDebugger:write(&quot;Bad request\n&quot;)&#13;&#10;      end&#13;&#10;&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;delb&quot; then&#13;&#10;      --{{{  delete breakpoint&#13;&#10;&#13;&#10;      local line, filename = getargs('LF')&#13;&#10;      if filename ~= '' and line ~= '' then&#13;&#10;        remove_breakpoint(filename, line)&#13;&#10;        ctrlrDebugger:write(&quot;Breakpoint deleted from file &quot;..filename..' line '..line..&quot;\n&quot;)&#13;&#10;      else&#13;&#10;        ctrlrDebugger:write(&quot;Bad request\n&quot;)&#13;&#10;      end&#13;&#10;&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;delallb&quot; then&#13;&#10;      --{{{  delete all breakpoints&#13;&#10;      breakpoints = {}&#13;&#10;      ctrlrDebugger:write('All breakpoints deleted\n')&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;listb&quot; then&#13;&#10;      --{{{  list breakpoints&#13;&#10;      for i, v in pairs(breakpoints) do&#13;&#10;        for ii, vv in pairs(v) do&#13;&#10;          ctrlrDebugger:write(&quot;Break at: &quot;..i..' in '..ii..'\n')&#13;&#10;        end&#13;&#10;      end&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;setw&quot; then&#13;&#10;      --{{{  set watch expression&#13;&#10;&#13;&#10;      if args and args ~= '' then&#13;&#10;        local func = loadstring(&quot;return(&quot; .. args .. &quot;)&quot;)&#13;&#10;        local newidx = #watches + 1&#13;&#10;        watches[newidx] = {func = func, exp = args}&#13;&#10;        ctrlrDebugger:write(&quot;Set watch exp no. &quot; .. newidx..'\n')&#13;&#10;      else&#13;&#10;        ctrlrDebugger:write(&quot;Bad request\n&quot;)&#13;&#10;      end&#13;&#10;&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;delw&quot; then&#13;&#10;      --{{{  delete watch expression&#13;&#10;&#13;&#10;      local index = tonumber(args)&#13;&#10;      if index then&#13;&#10;        watches[index] = nil&#13;&#10;        ctrlrDebugger:write(&quot;Watch expression deleted\n&quot;)&#13;&#10;      else&#13;&#10;        ctrlrDebugger:write(&quot;Bad request\n&quot;)&#13;&#10;      end&#13;&#10;&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;delallw&quot; then&#13;&#10;      --{{{  delete all watch expressions&#13;&#10;      watches = {}&#13;&#10;      ctrlrDebugger:write('All watch expressions deleted\n')&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;listw&quot; then&#13;&#10;      --{{{  list watch expressions&#13;&#10;      for i, v in pairs(watches) do&#13;&#10;        ctrlrDebugger:write(&quot;Watch exp. &quot; .. i .. &quot;: &quot; .. v.exp..'\n')&#13;&#10;      end&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;run&quot; then&#13;&#10;      --{{{  run until breakpoint&#13;&#10;      step_into = false&#13;&#10;      step_over = false&#13;&#10;      return 'cont'&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;step&quot; then&#13;&#10;      --{{{  step N lines (into functions)&#13;&#10;      local N = tonumber(args) or 1&#13;&#10;      step_over  = false&#13;&#10;      step_into  = true&#13;&#10;      step_lines = tonumber(N or 1)&#13;&#10;      return 'cont'&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;over&quot; then&#13;&#10;      --{{{  step N lines (over functions)&#13;&#10;      local N = tonumber(args) or 1&#13;&#10;      step_into  = false&#13;&#10;      step_over  = true&#13;&#10;      step_lines = tonumber(N or 1)&#13;&#10;      step_level[current_thread] = stack_level[current_thread]&#13;&#10;      return 'cont'&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;out&quot; then&#13;&#10;      --{{{  step N lines (out of functions)&#13;&#10;      local N = tonumber(args) or 1&#13;&#10;      step_into  = false&#13;&#10;      step_over  = true&#13;&#10;      step_lines = 1&#13;&#10;      step_level[current_thread] = stack_level[current_thread] - tonumber(N or 1)&#13;&#10;      return 'cont'&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;gotoo&quot; then&#13;&#10;      --{{{  step until reach line&#13;&#10;      local line, filename = getargs('LF')&#13;&#10;      if line ~= '' then&#13;&#10;        step_over  = false&#13;&#10;        step_into  = false&#13;&#10;        if has_breakpoint(filename,line) then&#13;&#10;          return 'cont'&#13;&#10;        else&#13;&#10;          set_breakpoint(filename,line,true)&#13;&#10;          return 'cont'&#13;&#10;        end&#13;&#10;      else&#13;&#10;        ctrlrDebugger:write(&quot;Bad request\n&quot;)&#13;&#10;      end&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;set&quot; then&#13;&#10;      --{{{  set/show context level&#13;&#10;      local level = args&#13;&#10;      if level and level == '' then level = nil end&#13;&#10;      if level then return level end&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;vars&quot; then&#13;&#10;      --{{{  list context variables&#13;&#10;      local depth = args&#13;&#10;      if depth and depth == '' then depth = nil end&#13;&#10;      depth = tonumber(depth) or 1&#13;&#10;      dumpvar(eval_env, depth+1, 'variables')&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;glob&quot; then&#13;&#10;      --{{{  list global variables&#13;&#10;      local depth = args&#13;&#10;      if depth and depth == '' then depth = nil end&#13;&#10;      depth = tonumber(depth) or 1&#13;&#10;      dumpvar(eval_env.__GLOBALS__,depth+1,'globals')&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;fenv&quot; then&#13;&#10;      --{{{  list function environment variables&#13;&#10;      local depth = args&#13;&#10;      if depth and depth == '' then depth = nil end&#13;&#10;      depth = tonumber(depth) or 1&#13;&#10;      dumpvar(eval_env.__ENVIRONMENT__,depth+1,'environment')&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;ups&quot; then&#13;&#10;      --{{{  list upvalue names&#13;&#10;      dumpvar(eval_env.__UPVALUES__,2,'upvalues')&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;locs&quot; then&#13;&#10;      --{{{  list locals names&#13;&#10;      dumpvar(eval_env.__LOCALS__,2,'upvalues')&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;what&quot; then&#13;&#10;      --{{{  show where a function is defined&#13;&#10;      if args and args ~= '' then&#13;&#10;        local v = eval_env&#13;&#10;        local n = nil&#13;&#10;        for w in string.gmatch(args,&quot;[%w_]+&quot;) do&#13;&#10;          v = v[w]&#13;&#10;          if n then n = n..'.'..w else n = w end&#13;&#10;          if not v then break end&#13;&#10;        end&#13;&#10;        if type(v) == 'function' then&#13;&#10;          local def = debug.getinfo(v,'S')&#13;&#10;          if def then&#13;&#10;            ctrlrDebugger:write(def.what..' in '..def.short_src..' '..def.linedefined..'..'..def.lastlinedefined..'\n')&#13;&#10;          else&#13;&#10;            ctrlrDebugger:write('Cannot get info for '..v..'\n')&#13;&#10;          end&#13;&#10;        else&#13;&#10;          ctrlrDebugger:write(v..' is not a function\n')&#13;&#10;        end&#13;&#10;      else&#13;&#10;        ctrlrDebugger:write(&quot;Bad request\n&quot;)&#13;&#10;      end&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;dump&quot; then&#13;&#10;      --{{{  dump a variable&#13;&#10;      local name, depth = getargs('VN')&#13;&#10;      if name ~= '' then&#13;&#10;        if depth == '' or depth == 0 then depth = nil end&#13;&#10;        depth = tonumber(depth or 1)&#13;&#10;        local v = eval_env&#13;&#10;        local n = nil&#13;&#10;        for w in string.gmatch(name,&quot;[&#94;%.]+&quot;) do     --get everything between dots&#13;&#10;          if tonumber(w) then&#13;&#10;            v = v[tonumber(w)]&#13;&#10;          else&#13;&#10;            v = v[w]&#13;&#10;          end&#13;&#10;          if n then n = n..'.'..w else n = w end&#13;&#10;          if not v then break end&#13;&#10;        end&#13;&#10;        dumpvar(v,depth+1,n)&#13;&#10;      else&#13;&#10;        ctrlrDebugger:write(&quot;Bad request\n&quot;)&#13;&#10;      end&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;show&quot; then&#13;&#10;      --{{{  show file around a line or the current breakpoint&#13;&#10;&#13;&#10;      local line, file, before, after = getargs('LFNN')&#13;&#10;      if before == 0 then before = 10     end&#13;&#10;      if after  == 0 then after  = before end&#13;&#10;&#13;&#10;      if file ~= '' and file ~= &quot;=stdin&quot; then&#13;&#10;        show(file,line,before,after)&#13;&#10;      else&#13;&#10;        ctrlrDebugger:write('Nothing to show\n')&#13;&#10;      end&#13;&#10;&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;poff&quot; then&#13;&#10;      --{{{  turn pause command off&#13;&#10;      pause_off = true&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;pon&quot; then&#13;&#10;      --{{{  turn pause command on&#13;&#10;      pause_off = false&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;tron&quot; then&#13;&#10;      --{{{  turn tracing on/off&#13;&#10;      local option = getargs('S')&#13;&#10;      trace_calls   = false&#13;&#10;      trace_returns = false&#13;&#10;      trace_lines   = false&#13;&#10;      if string.find(option,'c') then trace_calls   = true end&#13;&#10;      if string.find(option,'r') then trace_returns = true end&#13;&#10;      if string.find(option,'l') then trace_lines   = true end&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;trace&quot; then&#13;&#10;      --{{{  dump a stack trace&#13;&#10;      trace(eval_env.__VARSLEVEL__)&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;info&quot; then&#13;&#10;      --{{{  dump all debug info captured&#13;&#10;      info()&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;pause&quot; then&#13;&#10;      --{{{  not allowed in here&#13;&#10;      ctrlrDebugger:write('pause() should only be used in the script you are debugging\n')&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;help&quot; then&#13;&#10;      --{{{  help&#13;&#10;      local command = getargs('S')&#13;&#10;      if command ~= '' and hints[command] then&#13;&#10;        ctrlrDebugger:write(hints[command]..'\n')&#13;&#10;      else&#13;&#10;        for _,v in pairs(hints) do&#13;&#10;          local _,_,h = string.find(v,&quot;(.+)|&quot;)&#13;&#10;          ctrlrDebugger:write(h..'\n')&#13;&#10;        end&#13;&#10;      end&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif command == &quot;exit&quot; then&#13;&#10;      --{{{  exit debugger&#13;&#10;      return 'stop'&#13;&#10;      --}}}&#13;&#10;&#13;&#10;    elseif line ~= '' then&#13;&#10;      --{{{  just execute whatever it is in the current context&#13;&#10;&#13;&#10;      --map line starting with &quot;=...&quot; to &quot;return ...&quot;&#13;&#10;      if string.sub(line,1,1) == '=' then line = string.gsub(line,'=','return ',1) end&#13;&#10;&#13;&#10;      local ok, func = pcall(loadstring,line)&#13;&#10;      if func == nil then                             --Michael.Bringmann@lsi.com&#13;&#10;        ctrlrDebugger:write(&quot;Compile error: &quot;..line..'\n')&#13;&#10;      elseif not ok then&#13;&#10;        ctrlrDebugger:write(&quot;Compile error: &quot;..func..'\n')&#13;&#10;      else&#13;&#10;        setfenv(func, eval_env)&#13;&#10;        local res = {pcall(func)}&#13;&#10;        if res[1] then&#13;&#10;          if res[2] then&#13;&#10;            table.remove(res,1)&#13;&#10;            for _,v in ipairs(res) do&#13;&#10;              ctrlrDebugger:write(tostring(v))&#13;&#10;              ctrlrDebugger:write('\t')&#13;&#10;            end&#13;&#10;            ctrlrDebugger:write('\n')&#13;&#10;          end&#13;&#10;          --update in the context&#13;&#10;          return 0&#13;&#10;        else&#13;&#10;          ctrlrDebugger:write(&quot;Run error: &quot;..res[2]..'\n')&#13;&#10;        end&#13;&#10;      end&#13;&#10;&#13;&#10;      --}}}&#13;&#10;    end&#13;&#10;  end&#13;&#10;&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  local function debug_hook(event, line, level, thread)&#13;&#10;&#13;&#10;local function debug_hook(event, line, level, thread)&#13;&#10;  if not started then debug.sethook(); coro_debugger = nil; return end&#13;&#10;  current_thread = thread or 'main'&#13;&#10;  local level = level or 2&#13;&#10;  trace_event(event,line,level)&#13;&#10;  if event == &quot;call&quot; then&#13;&#10;    stack_level[current_thread] = stack_level[current_thread] + 1&#13;&#10;  elseif event == &quot;return&quot; then&#13;&#10;    stack_level[current_thread] = stack_level[current_thread] - 1&#13;&#10;    if stack_level[current_thread] &lt; 0 then stack_level[current_thread] = 0 end&#13;&#10;  else&#13;&#10;    local vars,file,line = capture_vars(level,1,line)&#13;&#10;    local stop, ev, idx = false, events.STEP, 0&#13;&#10;    while true do&#13;&#10;      for index, value in pairs(watches) do&#13;&#10;        setfenv(value.func, vars)&#13;&#10;        local status, res = pcall(value.func)&#13;&#10;        if status and res then&#13;&#10;          ev, idx = events.WATCH, index&#13;&#10;          stop = true&#13;&#10;          break&#13;&#10;        end&#13;&#10;      end&#13;&#10;      if stop then break end&#13;&#10;      if (step_into)&#13;&#10;      or (step_over and (stack_level[current_thread] &lt;= step_level[current_thread] or stack_level[current_thread] == 0)) then&#13;&#10;        step_lines = step_lines - 1&#13;&#10;        if step_lines &lt; 1 then&#13;&#10;          ev, idx = events.STEP, 0&#13;&#10;          break&#13;&#10;        end&#13;&#10;      end&#13;&#10;      if has_breakpoint(file, line) then&#13;&#10;        ev, idx = events.BREAK, 0&#13;&#10;        break&#13;&#10;      end&#13;&#10;      return&#13;&#10;    end&#13;&#10;    if not coro_debugger then&#13;&#10;      ctrlrDebugger:write(&quot;Lua Debugger\n&quot;)&#13;&#10;      vars, file, line = report(ev, vars, file, line, idx)&#13;&#10;      ctrlrDebugger:write(&quot;Type 'help' for commands\n&quot;)&#13;&#10;      coro_debugger = true&#13;&#10;    else&#13;&#10;      vars, file, line = report(ev, vars, file, line, idx)&#13;&#10;    end&#13;&#10;    tracestack(level)&#13;&#10;    local last_next = 1&#13;&#10;    local next = 'ask'&#13;&#10;    local silent = false&#13;&#10;    while true do&#13;&#10;      if next == 'ask' then&#13;&#10;        next = debugger_loop(ev, vars, file, line, idx)&#13;&#10;      elseif next == 'cont' then&#13;&#10;        return&#13;&#10;      elseif next == 'stop' then&#13;&#10;        started = false&#13;&#10;        debug.sethook()&#13;&#10;        coro_debugger = nil&#13;&#10;        return&#13;&#10;      elseif tonumber(next) then --get vars for given level or last level&#13;&#10;        next = tonumber(next)&#13;&#10;        if next == 0 then silent = true; next = last_next else silent = false end&#13;&#10;        last_next = next&#13;&#10;        restore_vars(level,vars)&#13;&#10;        vars, file, line = capture_vars(level,next)&#13;&#10;        if not silent then&#13;&#10;          if vars and vars.__VARSLEVEL__ then&#13;&#10;            ctrlrDebugger:write('Level: '..vars.__VARSLEVEL__..'\n')&#13;&#10;          else&#13;&#10;            ctrlrDebugger:write('No level set\n')&#13;&#10;          end&#13;&#10;        end&#13;&#10;        ev = events.SET&#13;&#10;        next = 'ask'&#13;&#10;      else&#13;&#10;        ctrlrDebugger:write('Unknown command from debugger_loop: '..tostring(next)..'\n')&#13;&#10;        ctrlrDebugger:write('Stopping debugger\n')&#13;&#10;        next = 'stop'&#13;&#10;      end&#13;&#10;    end&#13;&#10;  end&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;&#13;&#10;--{{{  coroutine.create&#13;&#10;&#13;&#10;--This function overrides the built-in for the purposes of propagating&#13;&#10;--the debug hook settings from the creator into the created coroutine.&#13;&#10;&#13;&#10;_G.coroutine.create = function(f)&#13;&#10;  local thread&#13;&#10;  local hook, mask, count = debug.gethook()&#13;&#10;  if hook then&#13;&#10;    local function thread_hook(event,line)&#13;&#10;      hook(event,line,3,thread)&#13;&#10;    end&#13;&#10;    thread = cocreate(function(...)&#13;&#10;                        stack_level[thread] = 0&#13;&#10;                        trace_level[thread] = 0&#13;&#10;                        step_level [thread] = 0&#13;&#10;                        debug.sethook(thread_hook,mask,count)&#13;&#10;                        return f(...)&#13;&#10;                      end)&#13;&#10;    return thread&#13;&#10;  else&#13;&#10;    return cocreate(f)&#13;&#10;  end&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  coroutine.wrap&#13;&#10;&#13;&#10;--This function overrides the built-in for the purposes of propagating&#13;&#10;--the debug hook settings from the creator into the created coroutine.&#13;&#10;&#13;&#10;_G.coroutine.wrap = function(f)&#13;&#10;  local thread&#13;&#10;  local hook, mask, count = debug.gethook()&#13;&#10;  if hook then&#13;&#10;    local function thread_hook(event,line)&#13;&#10;      hook(event,line,3,thread)&#13;&#10;    end&#13;&#10;    thread = cowrap(function(...)&#13;&#10;                      stack_level[thread] = 0&#13;&#10;                      trace_level[thread] = 0&#13;&#10;                      step_level [thread] = 0&#13;&#10;                      debug.sethook(thread_hook,mask,count)&#13;&#10;                      return f(...)&#13;&#10;                    end)&#13;&#10;    return thread&#13;&#10;  else&#13;&#10;    return cowrap(f)&#13;&#10;  end&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;&#13;&#10;--{{{  function pause(x,l,f)&#13;&#10;&#13;&#10;--&#13;&#10;-- Starts/resumes a debug session&#13;&#10;--&#13;&#10;&#13;&#10;function pause(x,l,f)&#13;&#10;  if not f and pause_off then return end       --being told to ignore pauses&#13;&#10;  pausemsg = x or 'pause'&#13;&#10;  local lines&#13;&#10;  local src = getinfo(2,'short_src')&#13;&#10;  if l then&#13;&#10;    lines = l   --being told when to stop&#13;&#10;  elseif src == &quot;stdin&quot; then&#13;&#10;    lines = 1   --if in a console session, stop now&#13;&#10;  else&#13;&#10;    lines = 2   --if in a script, stop when get out of pause()&#13;&#10;  end&#13;&#10;  if started then&#13;&#10;    --we'll stop now 'cos the existing debug hook will grab us&#13;&#10;    step_lines = lines&#13;&#10;    step_into  = true&#13;&#10;    debug.sethook(debug_hook, &quot;crl&quot;)         --reset it in case some external agent fiddled with it&#13;&#10;  else&#13;&#10;    --set to stop when get out of pause()&#13;&#10;    trace_level[current_thread] = 0&#13;&#10;    step_level [current_thread] = 0&#13;&#10;    stack_level[current_thread] = 1&#13;&#10;    step_lines = lines&#13;&#10;    step_into  = true&#13;&#10;    started    = true&#13;&#10;    debug.sethook(debug_hook, &quot;crl&quot;)         --NB: this will cause an immediate entry to the debugger_loop&#13;&#10;  end&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  function dump(v,depth)&#13;&#10;&#13;&#10;--shows the value of the given variable, only really useful&#13;&#10;--when the variable is a table&#13;&#10;--see dump debug command hints for full semantics&#13;&#10;&#13;&#10;function dump(v,depth)&#13;&#10;  dumpvar(v,(depth or 1)+1,tostring(v))&#13;&#10;end&#13;&#10;&#13;&#10;--}}}&#13;&#10;--{{{  function debug.traceback(x)&#13;&#10;&#13;&#10;local _traceback = debug.traceback       --note original function&#13;&#10;&#13;&#10;--override standard function&#13;&#10;debug.traceback = function(x)&#13;&#10;  local assertmsg = _traceback(x)        --do original function&#13;&#10;  pause(x)                               --let user have a look at stuff&#13;&#10;  return assertmsg                       --carry on&#13;&#10;end&#13;&#10;&#13;&#10;_TRACEBACK = debug.traceback             --Lua 5.0 function&#13;&#10;&#13;&#10;--}}}"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="00000000000000000000000000000005"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="inspect" luaMethodCode="function getInspect()&#13;&#10;local inspect ={&#13;&#10;  _VERSION = 'inspect.lua 3.0.0',&#13;&#10;  _URL     = 'http://github.com/kikito/inspect.lua',&#13;&#10;  _DESCRIPTION = 'human-readable representations of tables',&#13;&#10;  _LICENSE = [[&#13;&#10;    MIT LICENSE&#13;&#10;&#13;&#10;    Copyright (c) 2013 Enrique Garc&#237;a Cota&#13;&#10;&#13;&#10;    Permission is hereby granted, free of charge, to any person obtaining a&#13;&#10;    copy of this software and associated documentation files (the&#13;&#10;    &quot;Software&quot;), to deal in the Software without restriction, including&#13;&#10;    without limitation the rights to use, copy, modify, merge, publish,&#13;&#10;    distribute, sublicense, and/or sell copies of the Software, and to&#13;&#10;    permit persons to whom the Software is furnished to do so, subject to&#13;&#10;    the following conditions:&#13;&#10;&#13;&#10;    The above copyright notice and this permission notice shall be included&#13;&#10;    in all copies or substantial portions of the Software.&#13;&#10;&#13;&#10;    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS&#13;&#10;    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF&#13;&#10;    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.&#13;&#10;    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY&#13;&#10;    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,&#13;&#10;    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE&#13;&#10;    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&#13;&#10;  ]]&#13;&#10;}&#13;&#10;&#13;&#10;inspect.KEY       = setmetatable({}, {__tostring = function() return 'inspect.KEY' end})&#13;&#10;inspect.METATABLE = setmetatable({}, {__tostring = function() return 'inspect.METATABLE' end})&#13;&#10;&#13;&#10;-- Apostrophizes the string if it has quotes, but not aphostrophes&#13;&#10;-- Otherwise, it returns a regular quoted string&#13;&#10;local function smartQuote(str)&#13;&#10;  if str:match('&quot;') and not str:match(&quot;'&quot;) then&#13;&#10;    return &quot;'&quot; .. str .. &quot;'&quot;&#13;&#10;  end&#13;&#10;  return '&quot;' .. str:gsub('&quot;', '\\&quot;') .. '&quot;'&#13;&#10;end&#13;&#10;&#13;&#10;local controlCharsTranslation = {&#13;&#10;  [&quot;\a&quot;] = &quot;\\a&quot;,  [&quot;\b&quot;] = &quot;\\b&quot;, [&quot;\f&quot;] = &quot;\\f&quot;,  [&quot;\n&quot;] = &quot;\\n&quot;,&#13;&#10;  [&quot;\r&quot;] = &quot;\\r&quot;,  [&quot;\t&quot;] = &quot;\\t&quot;, [&quot;\v&quot;] = &quot;\\v&quot;&#13;&#10;}&#13;&#10;&#13;&#10;local function escape(str)&#13;&#10;  local result = str:gsub(&quot;\\&quot;, &quot;\\\\&quot;):gsub(&quot;(%c)&quot;, controlCharsTranslation)&#13;&#10;  return result&#13;&#10;end&#13;&#10;&#13;&#10;local function isIdentifier(str)&#13;&#10;  return type(str) == 'string' and str:match( &quot;&#94;[_%a][_%a%d]*$&quot; )&#13;&#10;end&#13;&#10;&#13;&#10;local function isSequenceKey(k, length)&#13;&#10;  return type(k) == 'number'&#13;&#10;     and 1 &lt;= k&#13;&#10;     and k &lt;= length&#13;&#10;     and math.floor(k) == k&#13;&#10;end&#13;&#10;&#13;&#10;local defaultTypeOrders = {&#13;&#10;  ['number']   = 1, ['boolean']  = 2, ['string'] = 3, ['table'] = 4,&#13;&#10;  ['function'] = 5, ['userdata'] = 6, ['thread'] = 7&#13;&#10;}&#13;&#10;&#13;&#10;local function sortKeys(a, b)&#13;&#10;  local ta, tb = type(a), type(b)&#13;&#10;&#13;&#10;  -- strings and numbers are sorted numerically/alphabetically&#13;&#10;  if ta == tb and (ta == 'string' or ta == 'number') then return a &lt; b end&#13;&#10;&#13;&#10;  local dta, dtb = defaultTypeOrders[ta], defaultTypeOrders[tb]&#13;&#10;  -- Two default types are compared according to the defaultTypeOrders table&#13;&#10;  if dta and dtb then return defaultTypeOrders[ta] &lt; defaultTypeOrders[tb]&#13;&#10;  elseif dta     then return true  -- default types before custom ones&#13;&#10;  elseif dtb     then return false -- custom types after default ones&#13;&#10;  end&#13;&#10;&#13;&#10;  -- custom types are sorted out alphabetically&#13;&#10;  return ta &lt; tb&#13;&#10;end&#13;&#10;&#13;&#10;local function getNonSequentialKeys(t)&#13;&#10;  local keys, length = {}, #t&#13;&#10;  for k,_ in pairs(t) do&#13;&#10;    if not isSequenceKey(k, length) then table.insert(keys, k) end&#13;&#10;  end&#13;&#10;  table.sort(keys, sortKeys)&#13;&#10;  return keys&#13;&#10;end&#13;&#10;&#13;&#10;local function getToStringResultSafely(t, mt)&#13;&#10;  local __tostring = type(mt) == 'table' and rawget(mt, '__tostring')&#13;&#10;  local str, ok&#13;&#10;  if type(__tostring) == 'function' then&#13;&#10;    ok, str = pcall(__tostring, t)&#13;&#10;    str = ok and str or 'error: ' .. tostring(str)&#13;&#10;  end&#13;&#10;  if type(str) == 'string' and #str &gt; 0 then return str end&#13;&#10;end&#13;&#10;&#13;&#10;local maxIdsMetaTable = {&#13;&#10;  __index = function(self, typeName)&#13;&#10;    rawset(self, typeName, 0)&#13;&#10;    return 0&#13;&#10;  end&#13;&#10;}&#13;&#10;&#13;&#10;local idsMetaTable = {&#13;&#10;  __index = function (self, typeName)&#13;&#10;    local col = setmetatable({}, {__mode = &quot;kv&quot;})&#13;&#10;    rawset(self, typeName, col)&#13;&#10;    return col&#13;&#10;  end&#13;&#10;}&#13;&#10;&#13;&#10;local function countTableAppearances(t, tableAppearances)&#13;&#10;  tableAppearances = tableAppearances or setmetatable({}, {__mode = &quot;k&quot;})&#13;&#10;&#13;&#10;  if type(t) == 'table' then&#13;&#10;    if not tableAppearances[t] then&#13;&#10;      tableAppearances[t] = 1&#13;&#10;      for k,v in pairs(t) do&#13;&#10;        countTableAppearances(k, tableAppearances)&#13;&#10;        countTableAppearances(v, tableAppearances)&#13;&#10;      end&#13;&#10;      countTableAppearances(getmetatable(t), tableAppearances)&#13;&#10;    else&#13;&#10;      tableAppearances[t] = tableAppearances[t] + 1&#13;&#10;    end&#13;&#10;  end&#13;&#10;&#13;&#10;  return tableAppearances&#13;&#10;end&#13;&#10;&#13;&#10;local copySequence = function(s)&#13;&#10;  local copy, len = {}, #s&#13;&#10;  for i=1, len do copy[i] = s[i] end&#13;&#10;  return copy, len&#13;&#10;end&#13;&#10;&#13;&#10;local function makePath(path, ...)&#13;&#10;  local keys = {...}&#13;&#10;  local newPath, len = copySequence(path)&#13;&#10;  for i=1, #keys do&#13;&#10;    newPath[len + i] = keys[i]&#13;&#10;  end&#13;&#10;  return newPath&#13;&#10;end&#13;&#10;&#13;&#10;local function processRecursive(process, item, path)&#13;&#10;  if item == nil then return nil end&#13;&#10;&#13;&#10;  local processed = process(item, path)&#13;&#10;  if type(processed) == 'table' then&#13;&#10;    local processedCopy = {}&#13;&#10;    local processedKey&#13;&#10;&#13;&#10;    for k,v in pairs(processed) do&#13;&#10;      processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY))&#13;&#10;      if processedKey ~= nil then&#13;&#10;        processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey))&#13;&#10;      end&#13;&#10;    end&#13;&#10;&#13;&#10;    local mt  = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE))&#13;&#10;    setmetatable(processedCopy, mt)&#13;&#10;    processed = processedCopy&#13;&#10;  end&#13;&#10;  return processed&#13;&#10;end&#13;&#10;&#13;&#10;&#13;&#10;-------------------------------------------------------------------&#13;&#10;&#13;&#10;local Inspector = {}&#13;&#10;local Inspector_mt = {__index = Inspector}&#13;&#10;&#13;&#10;function Inspector:puts(...)&#13;&#10;  local args   = {...}&#13;&#10;  local buffer = self.buffer&#13;&#10;  local len    = #buffer&#13;&#10;  for i=1, #args do&#13;&#10;    len = len + 1&#13;&#10;    buffer[len] = tostring(args[i])&#13;&#10;  end&#13;&#10;end&#13;&#10;&#13;&#10;function Inspector:down(f)&#13;&#10;  self.level = self.level + 1&#13;&#10;  f()&#13;&#10;  self.level = self.level - 1&#13;&#10;end&#13;&#10;&#13;&#10;function Inspector:tabify()&#13;&#10;  self:puts(self.newline, string.rep(self.indent, self.level))&#13;&#10;end&#13;&#10;&#13;&#10;function Inspector:alreadyVisited(v)&#13;&#10;  return self.ids[type(v)][v] ~= nil&#13;&#10;end&#13;&#10;&#13;&#10;function Inspector:getId(v)&#13;&#10;  local tv = type(v)&#13;&#10;  local id = self.ids[tv][v]&#13;&#10;  if not id then&#13;&#10;    id              = self.maxIds[tv] + 1&#13;&#10;    self.maxIds[tv] = id&#13;&#10;    self.ids[tv][v] = id&#13;&#10;  end&#13;&#10;  return id&#13;&#10;end&#13;&#10;&#13;&#10;function Inspector:putKey(k)&#13;&#10;  if isIdentifier(k) then return self:puts(k) end&#13;&#10;  self:puts(&quot;[&quot;)&#13;&#10;  self:putValue(k)&#13;&#10;  self:puts(&quot;]&quot;)&#13;&#10;end&#13;&#10;&#13;&#10;function Inspector:putTable(t)&#13;&#10;  if t == inspect.KEY or t == inspect.METATABLE then&#13;&#10;    self:puts(tostring(t))&#13;&#10;  elseif self:alreadyVisited(t) then&#13;&#10;    self:puts('&lt;table ', self:getId(t), '&gt;')&#13;&#10;  elseif self.level &gt;= self.depth then&#13;&#10;    self:puts('{...}')&#13;&#10;  else&#13;&#10;    if self.tableAppearances[t] &gt; 1 then self:puts('&lt;', self:getId(t), '&gt;') end&#13;&#10;&#13;&#10;    local nonSequentialKeys = getNonSequentialKeys(t)&#13;&#10;    local length            = #t&#13;&#10;    local mt                = getmetatable(t)&#13;&#10;    local toStringResult    = getToStringResultSafely(t, mt)&#13;&#10;&#13;&#10;    self:puts('{')&#13;&#10;    self:down(function()&#13;&#10;      if toStringResult then&#13;&#10;        self:puts(' -- ', escape(toStringResult))&#13;&#10;        if length &gt;= 1 then self:tabify() end&#13;&#10;      end&#13;&#10;&#13;&#10;      local count = 0&#13;&#10;      for i=1, length do&#13;&#10;        if count &gt; 0 then self:puts(',') end&#13;&#10;        self:puts(' ')&#13;&#10;        self:putValue(t[i])&#13;&#10;        count = count + 1&#13;&#10;      end&#13;&#10;&#13;&#10;      for _,k in ipairs(nonSequentialKeys) do&#13;&#10;        if count &gt; 0 then self:puts(',') end&#13;&#10;        self:tabify()&#13;&#10;        self:putKey(k)&#13;&#10;        self:puts(' = ')&#13;&#10;        self:putValue(t[k])&#13;&#10;        count = count + 1&#13;&#10;      end&#13;&#10;&#13;&#10;      if mt then&#13;&#10;        if count &gt; 0 then self:puts(',') end&#13;&#10;        self:tabify()&#13;&#10;        self:puts('&lt;metatable&gt; = ')&#13;&#10;        self:putValue(mt)&#13;&#10;      end&#13;&#10;    end)&#13;&#10;&#13;&#10;    if #nonSequentialKeys &gt; 0 or mt then -- result is multi-lined. Justify closing }&#13;&#10;      self:tabify()&#13;&#10;    elseif length &gt; 0 then -- array tables have one extra space before closing }&#13;&#10;      self:puts(' ')&#13;&#10;    end&#13;&#10;&#13;&#10;    self:puts('}')&#13;&#10;  end&#13;&#10;end&#13;&#10;&#13;&#10;function Inspector:putValue(v)&#13;&#10;  local tv = type(v)&#13;&#10;&#13;&#10;  if tv == 'string' then&#13;&#10;    self:puts(smartQuote(escape(v)))&#13;&#10;  elseif tv == 'number' or tv == 'boolean' or tv == 'nil' then&#13;&#10;    self:puts(tostring(v))&#13;&#10;  elseif tv == 'table' then&#13;&#10;    self:putTable(v)&#13;&#10;  else&#13;&#10;    self:puts('&lt;',tv,' ',self:getId(v),'&gt;')&#13;&#10;  end&#13;&#10;end&#13;&#10;&#13;&#10;-------------------------------------------------------------------&#13;&#10;&#13;&#10;function inspect.inspect(root, options)&#13;&#10;  options       = options or {}&#13;&#10;&#13;&#10;  local depth   = options.depth   or math.huge&#13;&#10;  local newline = options.newline or '\n'&#13;&#10;  local indent  = options.indent  or '  '&#13;&#10;  local process = options.process&#13;&#10;&#13;&#10;  if process then&#13;&#10;    root = processRecursive(process, root, {})&#13;&#10;  end&#13;&#10;&#13;&#10;  local inspector = setmetatable({&#13;&#10;    depth            = depth,&#13;&#10;    buffer           = {},&#13;&#10;    level            = 0,&#13;&#10;    ids              = setmetatable({}, idsMetaTable),&#13;&#10;    maxIds           = setmetatable({}, maxIdsMetaTable),&#13;&#10;    newline          = newline,&#13;&#10;    indent           = indent,&#13;&#10;    tableAppearances = countTableAppearances(root)&#13;&#10;  }, Inspector_mt)&#13;&#10;&#13;&#10;  inspector:putValue(root)&#13;&#10;&#13;&#10;  return table.concat(inspector.buffer)&#13;&#10;end&#13;&#10;&#13;&#10;setmetatable(inspect, { __call = function(_, ...) return inspect.inspect(...) end })&#13;&#10;&#13;&#10;return inspect&#13;&#10;end&#13;&#10;&#13;&#10;inspect = getInspect()"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="00000000000000000000000000000006"
                   luaMethodValid="1"/>
      </luaMethodGroup>
      <luaMethodGroup name="myMethods" uuid="d72304cdf1d14f0b9161143c3a854cb9">
        <luaMethod luaMethodName="myResetProgram" luaMethodCode="--&#10;-- Called when a modulator value changes&#10;-- @mod   http://ctrlr.org/api/class_ctrlr_modulator.html&#10;-- @value    new numeric value of the modulator&#10;--&#10;myResetProgram = function(--[[ CtrlrModulator --]] mod, --[[ number --]] value, --[[ number --]] source)&#13;&#10;  if panel:getBootstrapState() then&#13;&#10;        return&#13;&#10;    end&#13;&#10;&#9;if panel:getRestoreState() == true or panel:getProgramState() == true then&#13;&#10;&#9;&#9;return&#13;&#10;&#9;end&#13;&#10;if allowPopup==1 then&#13;&#10;q_reset=utils.questionWindow(&quot;Alert&quot;,&quot;Reset the program to startup values?\nAny downloaded patches in buffer will be lost\nCurrently you have &quot;..#big_dump_array..&quot; bytes in memory.&quot;, &quot;OK&quot;, &quot;Cancel&quot;)&#13;&#10;end --fi allowPopup&#13;&#10;if q_reset then&#13;&#10;initialise()&#13;&#10;else&#13;&#10;return&#13;&#10;end&#10;end --function&#13;&#10;---------------------------------------------------------"
                   luaMethodLinkedProperty="luaModulatorValueChange" luaMethodSource="0"
                   uuid="f91f055d567949bab9c9d72de695ca22" luaMethodValid="1"/>
        <luaMethod luaMethodName="myLoadFromFile" luaMethodCode="myLoadFromFile = function() -- loads a sysex file and uploads&#13;&#10;    if panel:getBootstrapState() then&#13;&#10;        return&#13;&#10;end&#13;&#10;&#9;if panel:getRestoreState() == true or panel:getProgramState() == true then&#13;&#10;&#9;&#9;return&#13;&#10;&#9;end&#13;&#10;&#13;&#10;iuCounter=0 --picked up by timer callback function&#13;&#10;upatch64=0 --picked up by timer callback function&#13;&#10;c = panel:getComponent(&quot;PROGRESSBAR&quot;)&#13;&#10;c:setComponentValue (0, true) &#13;&#10;c:setComponentText(&quot;Ready&quot;)&#13;&#10;local f = utils.openFileWindow(&quot;Open file&quot;, File.getSpecialLocation(File.userDesktopDirectory), &quot;*.syx&quot;, true)&#13;&#10;fileRead = File(f)&#13;&#10;&#13;&#10;local t={}&#13;&#10;local buf&#9;= MemoryBlock()&#13;&#10;fileRead:loadFileAsData(buf)&#13;&#10;buf:toLuaTable (t)&#13;&#10;sizeOfUpload=buf:getSize()&#13;&#10;upLoadArray={} --&gt; Global for timer&#13;&#10;j=1&#13;&#10;local tmp=&quot; &quot;&#13;&#10;for i,v in ipairs(t) do&#13;&#10;    h=string.format(&quot;%02x&quot;,v)&#13;&#10;    tmp=tmp..&quot; &quot;..h&#13;&#10;    if h==&quot;F7&quot; or h==&quot;f7&quot; then&#13;&#10;        upLoadArray[j]=trim1(tmp)&#13;&#10;        j=j+1&#13;&#10;        tmp='' -- reset&#13;&#10;    end&#13;&#10;end&#13;&#10;&#13;&#10;timer:setCallback (99, timerCallback)&#13;&#10;timer:startTimer(99,tu_rate) --[[360 seems okay 300 is too fast--]]&#13;&#10;&#13;&#10;panel:getCanvas():repaint()&#13;&#10;end --function&#13;&#10;---------------------------------------------------------"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="01c8f21a7c0e41fc87081e28f54e1be1"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="menuDisplay" luaMethodCode="--&#10;-- Called when a mouse is down on this component&#10;--&#10;&#10;menuDisplay = function(--[[ CtrlrComponent --]] comp, --[[ MouseEvent --]] event)&#10;   -- local  status =panel:getPanelEditor():getPropertyInt(&quot;uiPanelMenuBarVisible&quot;)&#13;&#10;   -- local b=flipZeroWithOne(status)&#13;&#10;   -- panel:getPanelEditor():setProperty(&quot;uiPanelMenuBarVisible&quot;,b,false)&#13;&#10;   -- if b == 0 then&#13;&#10;&#9;--&#9;panel:getComponent(&quot;SHOWMENU&quot;):setAlpha(0.0)&#13;&#10;   -- else&#13;&#10;&#9;--&#9;panel:getComponent(&quot;SHOWMENU&quot;):setAlpha(0.0)&#13;&#10;   -- end&#13;&#10;myHelp()&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;"
                   luaMethodLinkedProperty="componentLuaMouseDown" luaMethodSource="0"
                   uuid="c9afa2bda6a846f28fd0397ba70da375" luaMethodValid="1"/>
        <luaMethod luaMethodName="downloadSysex" luaMethodCode="--&#10;-- Called when a modulator value changes&#10;-- @mod   http://ctrlr.org/api/class_ctrlr_modulator.html&#10;-- @value    new numeric value of the modulator&#10;--&#10;downloadSysex = function(--[[ CtrlrModulator --]] mod, --[[ number --]] value, --[[ number --]] source)&#10;if panel:getBootstrapState() then&#13;&#10;        return&#13;&#10;    end   &#13;&#10;&#9;if panel:getRestoreState() == true or panel:getProgramState() == true then&#13;&#10;&#9;&#9;return&#13;&#10;&#9;end&#13;&#10;if allowPopup==1 then&#13;&#10;&#9; ret = AlertWindow.showOkCancelBox(&#13;&#10;&#9;&#9;AlertWindow.QuestionIcon, &#13;&#10;&#9;&#9;&quot;BULK DATA DUMP&quot;,&#13;&#10;&#9;&#9;&quot;Download all patches to sysex file?\n[I-11 - I-88] = 64 x Internal Patch\nTransfer rate of &quot;..dtr..&quot; recommended&quot;,&#13;&#10;&#9;&#9;&quot;OK&quot;,&#13;&#10;&#9;&#9;&quot;Cancel&quot;&#13;&#10;&#9;)&#13;&#10;end --fi allowPopup&#13;&#10;if ret==true then&#13;&#10;_killtimer=0&#13;&#10;panel:getComponent(&quot;SIZEOFDUMP&quot;):setProperty (&quot;uiLabelTextColour&quot;,&quot;FFFF0000&quot;,false)&#13;&#10;t_rate=tonumber(L(panel:getLabel(&quot;TRATE&quot;):getText()))--[[360 seems okay 300 is too fast--]]&#13;&#10;panel:getLabel(&quot;PROG&quot;):setText('')&#13;&#10;big_dump_array={} -- reset array&#13;&#10;printDumpArraySize()&#13;&#10;smiley(&quot;sad&quot;,1)--hide sad face&#13;&#10;smiley(&quot;happy&quot;,0)--show happy face&#13;&#10;if t_rate &lt; 1 or t_rate == nil then&#13;&#10;t_rate=dtr--default value&#13;&#10;end&#13;&#10;&#13;&#10;--[[&#13;&#10;&#13;&#10;--&gt; enable for JD-990 panel mySetModValue(&quot;TRIGBULKDUMP&quot;,1,true) --set the flag to pass midi to getMyBigDump&#13;&#10;pos={&#13;&#10;0x76,--&gt; 0x00 0x76 /*these are just sums of position 8-16 for checksum calculation&#13;&#10;0x78,--&gt; 0x00 0x76 /*these are just sums of position 8-16 for checksum calculation&#13;&#10;0xE8,--&gt; 0x00 0x76 /*these are just sums of position 8-16 for checksum calculation&#13;&#10;}&#13;&#10;&#13;&#10;data_pos={ --&gt; follows JD-990 Bulk Dump&#13;&#10;{0x00, 0x00, 0x00, 0x00, 0x00, 0x76},&#13;&#10;{0x00, 0x76, 0x00, 0x00, 0x02, 0x00},&#13;&#10;{0x02, 0x76, 0x00, 0x00, 0x00, 0x70},&#13;&#10;}&#13;&#10;--CONSTANTS&#13;&#10; a = 0xF0&#13;&#10; b = 0x41&#13;&#10; c = 0x10&#13;&#10; d = 0x57&#13;&#10; e = 0x11&#13;&#10; f = 0x06&#13;&#10; z = 0xF7&#13;&#10;&#13;&#10;for i=0,63 do&#13;&#10;&#13;&#10;for j=1,3 do&#13;&#10; cs=myCheckSum(6,pos[j],i)&#13;&#10; p = data_pos[j][1]&#13;&#10; q = data_pos[j][2]&#13;&#10; r = data_pos[j][3]&#13;&#10; s = data_pos[j][4]&#13;&#10; t = data_pos[j][5]&#13;&#10; u = data_pos[j][6]&#13;&#10;table.insert(a192,{a, b, c, d, e, f, i, p, q, r, s, t, u, cs, z})&#13;&#10;end&#13;&#10; &#13;&#10;end&#13;&#10;&#13;&#10;--]]&#13;&#10;&#13;&#10; a = 0xF0&#13;&#10; b = 0x41&#13;&#10; c = 0x0F&#13;&#10; d = 0x23&#13;&#10; e = 0x11&#13;&#10; f = 0x03&#13;&#10; g = 0x00&#13;&#10; h = 0x00&#13;&#10; i = 0x00&#13;&#10; j = 0x01&#13;&#10; k = 0x00&#13;&#10; z = 0xF7&#13;&#10;&#13;&#10; cs=myCheckSum(3, 1)&#13;&#10;table.insert(a192,{a, b, c, d, e, f, g, h, i, j, k, cs, z})&#13;&#10;&#13;&#10;&#13;&#10;panel:getComponent(&quot;SAVETOFILE&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(1))&#13;&#10;panel:getComponent(&quot;RESETSWITCH&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(1))&#13;&#10;panel:getComponent(&quot;UPLOADFILE&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(1))&#13;&#10;iCounter=0 --picked up by timer callback function&#13;&#10;patch64=0 --picked up by timer callback function&#13;&#10;c = panel:getComponent(&quot;PROGRESSBAR&quot;)&#13;&#10;c:setComponentValue (0, true) &#13;&#10;c:setComponentText(&quot;Ready&quot;)&#13;&#10;timer:setCallback (11, timerCallback)&#13;&#10;timer:startTimer(11,t_rate) --[[360 seems okay 300 is too fast--]]&#13;&#10;&#13;&#10;end -- ret = true&#13;&#10;end --function&#13;&#10;"
                   luaMethodLinkedProperty="luaModulatorValueChange" luaMethodSource="0"
                   uuid="134ebcd9c84a4d308ac441bfdbfa1692" luaMethodValid="1"/>
        <luaMethod luaMethodName="uploadSysex" luaMethodCode="--&#10;-- Called when a modulator value changes&#10;-- @mod   http://ctrlr.org/api/class_ctrlr_modulator.html&#10;-- @value    new numeric value of the modulator&#10;--&#10;uploadSysex = function(--[[ CtrlrModulator --]] mod, --[[ number --]] value, --[[ number --]] source)&#13;&#10;if panel:getBootstrapState() then&#13;&#10;        return&#13;&#10;    end   &#13;&#10;&#9;if panel:getRestoreState() == true or panel:getProgramState() == true then&#13;&#10;&#9;&#9;return&#13;&#10;&#9;end&#13;&#10;&#9; ret = AlertWindow.showOkCancelBox(&#13;&#10;&#9;&#9;AlertWindow.QuestionIcon, &#13;&#10;&#9;&#9;&quot;UPLOAD SYSEX FILE TO JD-990?&quot;,&#13;&#10;&#9;&#9;&quot;Upload all patches from sysex file on computer to JD-990?\n[I-11 - I-88] = 64 x Internal Patch\nTransfer rate of &quot;..utr..&quot; recommended\n\nMake sure the JD-990 is not Write Protected!!!\n[1] UTILITY\n[2] Protect [F6]\n[3] Internal Protect [OFF]\n\nTotal upload size of sysex file should be 33216 bytes&quot;,&#13;&#10;&#9;&#9;&quot;OK&quot;,&#13;&#10;&#9;&#9;&quot;Cancel&quot;&#13;&#10;&#9;)&#13;&#10;if ret==true then&#13;&#10;_killtimer=0&#13;&#10;panel:getComponent(&quot;SIZEOFDUMP&quot;):setProperty (&quot;uiLabelTextColour&quot;,&quot;FFFF0000&quot;,false)&#13;&#10;big_dump_array={} -- reset&#13;&#10;printDumpArraySize()&#13;&#10;panel:getLabel(&quot;PROG&quot;):setText('')&#13;&#10;smiley(&quot;sad&quot;,1)--hide sad face&#13;&#10;smiley(&quot;happy&quot;,0)--show happy face&#13;&#10;&#13;&#10;tu_rate=tonumber(L(panel:getLabel(&quot;TRATE&quot;):getText()))--[[150 seems okay 100 is too fast--]]&#13;&#10;panel:getLabel(&quot;PROG&quot;):setText('')&#13;&#10;&#13;&#10;if tu_rate &lt; 1 or tu_rate == nil then&#13;&#10;tu_rate=utr--default value&#13;&#10;end&#13;&#10;panel:getComponent(&quot;SAVETOFILE&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(1))&#13;&#10;panel:getComponent(&quot;RESETSWITCH&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(1))&#13;&#10;panel:getComponent(&quot;myBigDump&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(1))&#13;&#10;myLoadFromFile()&#13;&#10;end -- ret = true&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;"
                   luaMethodLinkedProperty="luaModulatorValueChange" luaMethodSource="0"
                   uuid="5b36f43ad6a94ae68e7d93e583cea1ec" luaMethodValid="1"/>
        <luaMethod luaMethodName="functions" luaMethodCode="--[[&#13;&#10;/******************************************&#13;&#10;*&#13;&#10;*&#9;&#9;MISCELLANEOUS FUNCTIONS&#13;&#10;*&#13;&#10;******************************************/&#13;&#10;--]]&#13;&#10;&#13;&#10;function round(num, numDecimalPlaces) -- rounding function&#13;&#10;  local mult = 10&#94;(numDecimalPlaces or 0)&#13;&#10;  return math.floor(num * mult + 0.5) / mult&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;myGetModValue =  function(myModulator)&#13;&#10;    local val = panel:getModulatorByName(myModulator):getModulatorValue()&#13;&#10;    return val&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;mySetModValue =  function(myModulator,value,sendNotification)&#13;&#10;    panel:getModulatorByName(myModulator):getComponent():setValue (value,sendNotification)&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;function trim1(s) -- remove trailing / leading space &#13;&#10;    return (s:gsub(&quot;&#94;%s*(.-)%s*$&quot;, &quot;%1&quot;))&#13;&#10;end --function&#13;&#10;--------------------------------------------------------&#13;&#10;myCheckSum=function(...) -- Roland Checksum&#13;&#10;--//use mod(a,b) function as % modulo.&#13;&#10;--//add the address bytes&#13;&#10;--//and the data bits together&#13;&#10;--//divide by 128, &#13;&#10;--//and subtract the remainder from 128. &#13;&#10;--//This yields a number from 1 to 128,&#13;&#10;--//not 0 to 127 as we need, &#13;&#10;--//**so if the answer is 128 change it into a 0.&#13;&#10;--https://www.bome.com/forums/viewtopic.php?t=11986&#13;&#10;local sum=0&#13;&#10;local result=0&#13;&#10;for _,v in ipairs(arg) do&#13;&#10;sum=sum+v&#13;&#10;end&#13;&#10;--// calculate the remainder of sum/128&#13;&#10;local remainder=mod(sum,128)&#13;&#10;--// subtract the remainder from 128&#13;&#10;result=128 - remainder&#13;&#10;if result==128 then result=0 end --//**&#13;&#10;return result&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;function mod(a, b) -- % modulo&#13;&#10;--    return a - (math.floor(a/b)*b)&#13;&#10;return a % b&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;printVersion=function()&#13;&#10;&#9;local ver={}&#13;&#10;    table.insert(ver,&quot;Version: &quot;)&#13;&#10;    table.insert(ver,panel:getProperty(&quot;panelVersionMajor&quot;))&#13;&#10;&#9;table.insert(ver,'.')&#13;&#10;    table.insert(ver,panel:getProperty(&quot;panelVersionMinor&quot;))&#13;&#10;&#9;table.insert(ver,' ')&#13;&#10;&#9;table.insert(ver,panel:getProperty(&quot;panelVersionName&quot;))&#13;&#10;      panel:getModulatorByName(&quot;VERSION&quot;):getComponent():setPropertyString(&quot;uiLabelText&quot;,table.concat(ver))&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;flipZeroWithOne=function(n)&#13;&#10;    local c = n*0&#13;&#10;    if n == 0 then c = 1 end&#13;&#10;    return c&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;function printDumpArraySize()&#13;&#10;panel:getLabel(&quot;SIZEOFDUMP&quot;):setText(tostring(#big_dump_array..' bytes'))&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;function smiley(me,show) &#13;&#10;if me == &quot;happy&quot; then -- :)&#13;&#10;&#13;&#10;if show ==1 then&#13;&#10;panel:getModulatorByName(&quot;SMILE&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;1&quot;)&#13;&#10;panel:getModulatorByName(&quot;BALLOON&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;1&quot;)&#13;&#10;panel:getModulatorByName(&quot;SMILEN&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;0&quot;)&#13;&#10;panel:getModulatorByName(&quot;BALLOONN&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;0&quot;)&#13;&#10;else&#13;&#10;panel:getModulatorByName(&quot;SMILE&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;0&quot;)&#13;&#10;panel:getModulatorByName(&quot;BALLOON&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;0&quot;)&#13;&#10;end&#13;&#10; end&#13;&#10;&#13;&#10;if me == &quot;sad&quot; then -- :(&#13;&#10;--s=panel:getModulatorByName(&quot;SMILEN&quot;)&#13;&#10;if show ==1 then&#13;&#10;panel:getModulatorByName(&quot;SMILEN&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;1&quot;)&#13;&#10;panel:getModulatorByName(&quot;BALLOONN&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;1&quot;)&#13;&#10;panel:getModulatorByName(&quot;SMILE&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;0&quot;)&#13;&#10;panel:getModulatorByName(&quot;BALLOON&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;0&quot;)&#13;&#10;else&#13;&#10;panel:getModulatorByName(&quot;SMILEN&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;0&quot;)&#13;&#10;panel:getModulatorByName(&quot;BALLOONN&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;0&quot;)&#13;&#10;end&#13;&#10; end&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;myHelp=function()&#13;&#10; if panel:getBootstrapState() then&#13;&#10;        return&#13;&#10;    end&#13;&#10;&#9;if panel:getRestoreState() == true or panel:getProgramState() == true then&#13;&#10;&#9;&#9;return&#13;&#10;&#9;end&#13;&#10;local detail= [[&#13;&#10;Why does a full Internal Patch dump on the Roland JD-990 = 33216 bytes?&#13;&#10;&#13;&#10;Total memory for each patch = 486 bytes:&#13;&#10;64 patches * 486 = 31104 bytes&#13;&#10;There are 192 sysex messages transfered (3 for each patch 192/3 = 64)&#13;&#10;&#13;&#10;Example::&#13;&#10;F0 41 10 57 12 06 00 00 00 + Checksum and F7 = 11 bytes extra per sysex message&#13;&#10;192 * 11 = 2,112 bytes&#13;&#10;&#13;&#10;31,104 + 2,112 = 33,216&#13;&#10;]]&#13;&#10;if allowPopup == 1 then&#13;&#10;file = utils.infoWindow (&quot;Information&quot;,detail)&#13;&#10;end&#13;&#10;end&#13;&#10;&#13;&#10;"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="4b71be9ed1e744619fd4db3570089596"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="prepareFileSave" luaMethodCode="--&#10;-- Called when a modulator value changes&#10;-- @mod   http://ctrlr.org/api/class_ctrlr_modulator.html&#10;-- @value    new numeric value of the modulator&#10;--&#13;&#10;prepareFileSave = function(--[[ CtrlrModulator --]] mod, --[[ number --]] value, --[[ number --]] source)&#13;&#10; if panel:getBootstrapState() then&#13;&#10;        return&#13;&#10;    end&#13;&#10;&#9;if panel:getRestoreState() == true or panel:getProgramState() == true then&#13;&#10;&#9;&#9;return&#13;&#10;&#9;end&#13;&#10;local ts=table.getn(big_dump_array)&#13;&#10;&#13;&#10;if #big_dump_array &lt; 1 then&#13;&#10;if allowPopup==1 then&#13;&#10;&#9;utils.warnWindow(&quot;Program information&quot;, &quot;Error: File for saving to sysex is 0 bytes&quot;)&#13;&#10;end --fi allowPopup&#13;&#10;&#9;&#9;&#9;return&#13;&#10;end -- size not big enough ~~  Bail out&#13;&#10;local currentTrate=L(panel:getLabel(&quot;TRATE&quot;):getText())&#13;&#10;if #big_dump_array ~= 33216 then&#13;&#10;if allowPopup==1 then&#13;&#10;notfull=utils.questionWindow(&quot;WARNING!&quot;,&quot;Your sysex file should be 33216 bytes!\nYour file is &quot;..ts..&quot; bytes.\nIf you are &quot;..(33216-ts)..&quot; bytes short, there may have been a buffer overflow.\n\nIf you see \&quot;MIDI Buffer Full\&quot; on the JD-990,\ntry increasing the transfer rate delay up from &quot;..currentTrate..&quot; milliseconds.\n\nProceed to save file anyway or Cancel?&quot;, &quot;OK&quot;, &quot;Cancel&quot;)&#13;&#10;end --fi allowPopup&#13;&#10;if notfull then&#13;&#10;--proceed&#13;&#10;else&#13;&#10;return&#13;&#10;end&#13;&#10;&#9;end&#13;&#10;if allowPopup == 1 then&#13;&#10; ret = AlertWindow.showOkCancelBox(&#13;&#10;&#9;&#9;AlertWindow.QuestionIcon, &#13;&#10;&#9;&#9;&quot;BULK DATA DUMP&quot;,&#13;&#10;&#9;&#9;&quot;Save to external file?\n[I-11 - I-88] = 64 patches in RAM&quot;,&#13;&#10;&#9;&#9;&quot;OK&quot;,&#13;&#10;&#9;&#9;&quot;Cancel&quot;&#13;&#10;&#9;)&#13;&#10;end -- fi allowPopup&#13;&#10;if ret==true then&#13;&#10;mB=MemoryBlock.fromLuaTable(big_dump_array)&#13;&#10;saveToFile(mB)&#13;&#10;&#13;&#10;end&#13;&#10;end --function&#13;&#10;---------------------------------------------------------"
                   luaMethodLinkedProperty="luaModulatorValueChange" luaMethodSource="0"
                   uuid="c4af7c87f7bb41bfa2d375624e5b9999" luaMethodValid="1"/>
        <luaMethod luaMethodName="saveToFile" luaMethodCode="function saveToFile(dataToSave) -- save memoryBlock to .syx file&#13;&#10;    if panel:getBootstrapState() then&#13;&#10;        return&#13;&#10;end&#13;&#10;&#9;if panel:getRestoreState() == true or panel:getProgramState() == true then&#13;&#10;&#9;&#9;return&#13;&#10;&#9;end&#13;&#10;file = utils.saveFileWindow (&quot;Save file&quot;,File.getSpecialLocation(File.userDesktopDirectory), &quot;*.syx&quot;, true)&#13;&#10;if file:hasWriteAccess() then&#13;&#10;    file:replaceWithData(dataToSave)&#13;&#10;end&#13;&#10;--&gt; enable for JD-990 panel mySetModValue(&quot;TRIGBULKDUMP&quot;,0,true) -- reset global variable&#13;&#10;end --function&#13;&#10;---------------------------------------------------------"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="3c11e01729c24d91abc90c636d179541"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="killtimer" luaMethodCode="--&#10;-- Called when a modulator value changes&#10;-- @mod   http://ctrlr.org/api/class_ctrlr_modulator.html&#10;-- @value    new numeric value of the modulator&#10;--&#10;killtimer = function(--[[ CtrlrModulator --]] mod, --[[ number --]] value, --[[ number --]] source)&#13;&#10;--&gt; enable for JD-990 panel mySetModValue(&quot;TRIGBULKDUMP&quot;,0,true)&#13;&#10;  if panel:getBootstrapState() then&#13;&#10;        return&#13;&#10;    end&#13;&#10;&#9;if panel:getRestoreState() == true or panel:getProgramState() == true then&#13;&#10;&#9;&#9;return&#13;&#10;&#9;end&#13;&#10;_killtimer=1&#13;&#10;c = panel:getComponent(&quot;PROGRESSBAR&quot;) -- re crete object and reset&#13;&#10;c:setComponentValue (0, true) --&gt; spinner&#13;&#10;c:setComponentText(&quot;Ready&quot;)&#13;&#10;panel:getComponent(&quot;RESETSWITCH&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0))&#13;&#10;panel:getComponent(&quot;SAVETOFILE&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0))&#13;&#10;panel:getLabel(&quot;PROG&quot;):setText('')&#13;&#10;smiley(&quot;sad&quot;,0)--hide sad face&#13;&#10;smiley(&quot;happy&quot;,0)--hide happy face&#10;end"
                   luaMethodLinkedProperty="luaModulatorValueChange" luaMethodSource="0"
                   uuid="5ba24e219c4d4d39b67a86151466c060" luaMethodValid="1"/>
        <luaMethod luaMethodName="initialise" luaMethodCode="function initialise()&#10;&#9;-- Your method code here [ add 24 to canvas size ]&#13;&#10;dtr=400 -- default recommneded download rate in milliseconds&#13;&#10;utr=150 -- default recommneded upload rate in milliseconds&#13;&#10; panel:getPanelEditor():setProperty(&quot;uiPanelZoom&quot;, 1,true) -- reset 1:1 zoom&#13;&#10;a192={} -- array initialisation&#13;&#10;--&gt; enable for JD-990 panel mySetModValue(&quot;TRIGBULKDUMP&quot;,0,true) &#13;&#10;--&gt; TRIGBULKDUMP :: this doesn't do anything it's intended for use in another program JD-990 Super Editor&#13;&#10;big_dump_array={} -- array initialisation&#13;&#10;_killtimer=0  -- global variable initialisation&#13;&#10;allowPopup=0&#13;&#10;&#9;timer:setCallback (1, timerCallback) -- STOPS POPUPS FROM POPPING UP ON PROGRAM LOAD&#13;&#10;&#9;timer:startTimer(1, 50)&#9;&#13;&#10;&#13;&#10;&#9;panel:getLabel(&quot;debugOutputLabel&quot;):setText('') --panel initialisation&#13;&#10;&#9;panel:getLabel(&quot;PROG&quot;):setText('') --panel initialisation&#13;&#10;    panel:getModulatorByName(&quot;TRATE&quot;):getComponent():setPropertyString(&quot;uiLabelText&quot;,tostring(dtr)) --panel initialisation&#13;&#10;&#13;&#10;panel:getComponent(&quot;SAVETOFILE&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0)) --panel initialisation&#13;&#10;panel:getComponent(&quot;RESETSWITCH&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0)) --panel initialisation&#13;&#10;panel:getComponent(&quot;myBigDump&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0)) --panel initialisation&#13;&#10;panel:getComponent(&quot;UPLOADFILE&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0)) --panel initialisation&#13;&#10;&#13;&#10;e = panel:getComponent(&quot;PROGRESSBAR&quot;) -- Progress Bar initialisation&#13;&#10;e:setComponentValue (0, true)  -- Progress Bar initialisation&#13;&#10;e:setComponentText(&quot;Ready&quot;) -- Progress Bar initialisation&#13;&#10;printVersion() --panel initialisation&#13;&#10;panel:getPanelEditor():setProperty(&quot;uiPanelMenuBarVisible&quot;,1,false) --panel initialisation&#13;&#10;panel:getComponent(&quot;SHOWMENU&quot;):setAlpha(0.0) --panel initialisation&#13;&#10;printDumpArraySize() --panel initialisation&#13;&#10;panel:getComponent(&quot;SIZEOFDUMP&quot;):setProperty (&quot;uiLabelTextColour&quot;,&quot;FFFF0000&quot;,false) --panel initialisation&#13;&#10;smiley(&quot;sad&quot;,0)--hide sad face&#13;&#10;smiley(&quot;happy&quot;,0)--hide happy face&#13;&#10;--panel:getModulatorByName(&quot;SMILE&quot;):getComponent():setPropertyString(&quot;componentVisibility&quot;,&quot;0&quot;)&#13;&#10;end --function&#13;&#10;---------------------------------------------------------&#13;&#10;--[[&#13;&#10;Why does a full Internal Patch dump on the Roland JD-990 = 33216 bytes?&#13;&#10;&#13;&#10;Total memory for each patch = 486 bytes&#13;&#10;64 patches * 486 = 31104 bytes&#13;&#10;There are 192 sysex messages transfered (3 for each patch 192/3 = 64)&#13;&#10; &#13;&#10;F0 41 10 57 12 06 00 00 00 + Checksum and F7 = 11 bytes extra per sysex message&#13;&#10;192 * 11 = 2,112 bytes&#13;&#10;&#13;&#10;31,104 + 2,112 = 33,216&#13;&#10;--]]"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="fabf3110fea046acaa6a84bf3774ad51"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="myGetBigDump" luaMethodCode="getMyBigDump = function(m,len)&#10;  if panel:getBootstrapState() then&#13;&#10;        return&#13;&#10;    end&#13;&#10;&#9;if panel:getRestoreState() == true or panel:getProgramState() == true then&#13;&#10;&#9;&#9;return&#13;&#10;&#9;end&#13;&#10;local temp_string='' --&gt; initialise&#13;&#10;        for i=0,len-1 do&#13;&#10;            m:getLuaData():getByte(i)&#13;&#10;      table.insert(big_dump_array,m:getLuaData():getByte(i))&#13;&#10;if #big_dump_array==33216 then&#13;&#10;printDumpArraySize()&#13;&#10;panel:getComponent(&quot;SIZEOFDUMP&quot;):setProperty (&quot;uiLabelTextColour&quot;,&quot;FF0000FF&quot;,false)&#13;&#10;smiley(&quot;sad&quot;,0)--hide sad face&#13;&#10;smiley(&quot;happy&quot;,1)--show happy face&#13;&#10;--/****************************************************/&#13;&#10;else&#13;&#10;printDumpArraySize()&#13;&#10;end&#13;&#10;  &#9;&#9;&#9;&#13;&#10;end&#13;&#10;end --function&#13;&#10;---------------------------------------------------------"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="eb7f52e5443d4ed0a86228bda24a8553"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="myMidiReceived" luaMethodCode="--&#13;&#10;-- Called when a panel receives a midi message (does not need to match any modulator mask)&#13;&#10;-- @midi   CtrlrMidiMessage object&#13;&#10;--&#13;&#10;myMidiReceived = function(--[[ CtrlrMidiMessage --]] midi)&#13;&#10;    local s = midi:getSize()&#13;&#10;---------------------------------------------------------------&#13;&#10;--[[    &#13;&#10;if s ~=3 then&#13;&#10;       console(String(&quot;midi:size =&gt; &quot;..s))&#13;&#10;&#13;&#10;    end&#13;&#10;---------------------------------------------------------------&#13;&#10;--]]&#13;&#10;    if s ==  123 then&#13;&#10;&#9;&#9;-- enable for JD-990 panelif myGetModValue(&quot;TRIGBULKDUMP&quot;) == 1 then&#13;&#10;&#9;&#9;&#9;getMyBigDump(midi,s)&#13;&#10;&#9;--&gt; enable for JD-990 panel &#13;&#10;    end --  received bytes :: 123    &#13;&#10;&#13;&#10;---------------------------------------------------------------&#13;&#10;    if s ==  129 then&#13;&#10;&#9;&#9;--&gt; enable for JD-990 panel if myGetModValue(&quot;TRIGBULKDUMP&quot;) == 1 then&#13;&#10;&#9;&#9;&#9;getMyBigDump(midi,s)&#13;&#10;&#9;--&gt; enable for JD-990 panel &#13;&#10;    end --end received bytes :: 129&#13;&#10;---------------------------------------------------------------&#13;&#10;    if s == 267 then&#13;&#10;&#9;&#9;--if myGetModValue(&quot;TRIGBULKDUMP&quot;) == 1 then&#13;&#10;&#9;&#9;&#9;getMyBigDump(midi,s)&#13;&#10;&#9;--&gt; enable for JD-990 panel &#13;&#10;    end --  received bytes :: 267    &#13;&#10;end --function&#13;&#10;---------------------------------------------------------"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="8af781a1734f42c4a6e237f3f1ede23f"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="timer" luaMethodCode="timerCallback = function(timerId) -- this function name must match the name above in the first line. ;)&#13;&#10;  if panel:getBootstrapState() then&#13;&#10;        return&#13;&#10;    end&#13;&#10;&#9;if panel:getRestoreState() == true or panel:getProgramState() == true then&#13;&#10;&#9;&#9;return&#13;&#10;&#9;end&#13;&#10;--/******************************************&#13;&#10;--*&#13;&#10;--*&#13;&#10;--*&#9;&#9;&#9;DOWNLOAD FROM JD-990&#13;&#10;--*&#13;&#10;--*&#13;&#10;--******************************************/&#13;&#10;&#9;if timerId == 1 then  -- STOPS POPUPS FROM POPPING UP ON PROGRAM LOAD&#13;&#10;&#9;&#9;allowPopup = 1&#13;&#10;&#9;&#9;timer:stopTimer(timerId)&#13;&#10;--/**************************************/&#13;&#10;&#13;&#10;elseif timerId == 11 then -- create dump of Sysex re:function downloadSysex&#13;&#10;    mb = MemoryBlock ({a192[iCounter+1][1],a192[iCounter+1][2],&#13;&#10;        a192[iCounter+1][3],a192[iCounter+1][4],a192[iCounter+1][5],a192[iCounter+1][6],a192[iCounter+1][7],a192[iCounter+1][8],&#13;&#10;        a192[iCounter+1][9],a192[iCounter+1][10],a192[iCounter+1][11],a192[iCounter+1][12],a192[iCounter+1][13],&#13;&#10;        a192[iCounter+1][14],a192[iCounter+1][15]})-- creates a HEX string to send below&#13;&#10;panel:sendMidiMessageNow(CtrlrMidiMessage(mb))&#13;&#10;iCounter=iCounter+1&#13;&#10;local endLoop=#a192&#13;&#10;percentComplete=round(iCounter/endLoop*100,0)&#13;&#10;local bar=round(iCounter/endLoop,2)&#13;&#10;if mod(iCounter,3)==0 then &#13;&#10;patch64=patch64+1 &#13;&#10;end&#13;&#10;c:setComponentValue (bar, false) --&gt; percentage complete&#13;&#10;c:setComponentText(&quot;Please wait:: &quot;..percentComplete..&quot;% complete&quot;)&#13;&#10;panel:getLabel(&quot;PROG&quot;):setText('['..patch64..' of 64 patches downloaded]')&#13;&#10;panel:getLabel(&quot;debugOutputLabel&quot;):setText(mb:toHexString(1))&#13;&#10;&#13;&#10;&#9;&#9;&#13;&#10;--/******************COMPLETION CLEANUP********************/&#13;&#10;&#13;&#10;if iCounter &gt;= endLoop or _killtimer==1 then&#13;&#10;    timer:stopTimer(timerId)&#13;&#10;    a192={} --reset&#13;&#10;    iCounter=0 -- reset&#13;&#10;    --&gt; enable for JD-990 panel mySetModValue(&quot;TRIGBULKDUMP&quot;,0,true)&#13;&#10;    c:setComponentValue (0, true) --&gt; percentage complete&#13;&#10;    c:setComponentText(&quot;Complete&quot;)&#13;&#10;&#13;&#10;if _killtimer == 1 then&#13;&#10;    panel:getLabel(&quot;debugOutputLabel&quot;):setText('process interrupted')&#13;&#10;else&#13;&#10;    panel:getLabel(&quot;debugOutputLabel&quot;):setText('process complete')&#13;&#10;&#13;&#10;end&#13;&#10;    _killtimer=0&#13;&#10;    panel:getComponent(&quot;RESETSWITCH&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0))&#13;&#10;    panel:getComponent(&quot;SAVETOFILE&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0))&#13;&#10;    panel:getComponent(&quot;UPLOADFILE&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0))&#13;&#10;&#13;&#10;end&#13;&#10;--/******************************************&#13;&#10;--*&#13;&#10;--*&#13;&#10;--*&#9;&#9;&#9;UPLOAD TO JD-990&#13;&#10;--*&#13;&#10;--*&#13;&#10;--******************************************/&#13;&#10;elseif timerId == 99 then -- upload SYSEX re:function uploadSysex&#13;&#10;iuCounter=iuCounter+1&#13;&#10;if mod(iuCounter,3)==0 then upatch64=upatch64+1 end&#13;&#10;panel:sendMidiMessageNow(CtrlrMidiMessage(upLoadArray[iuCounter]))&#13;&#10;local uendLoop=#upLoadArray&#13;&#10;percentComplete=round(iuCounter/uendLoop*100,0)&#13;&#10;local bar=round(iuCounter/uendLoop,2)&#13;&#10;c:setComponentValue (bar, false) --&gt; percentage complete&#13;&#10;c:setComponentText(&quot;Please wait:: &quot;..percentComplete..&quot;% complete&quot;)&#13;&#10;panel:getLabel(&quot;PROG&quot;):setText('[Uploading patch '..upatch64..' of 64] Filesize = '..sizeOfUpload..' bytes')&#13;&#10;if #upLoadArray &gt;0 and upLoadArray ~=nil then&#13;&#10;local subS=string.sub(upLoadArray[iuCounter], 19, 35)&#13;&#10;pCS=string.sub(upLoadArray[iuCounter],-5, -4)&#13;&#10;panel:getLabel(&quot;debugOutputLabel&quot;):setText('F0 41 10 57 12 06 '..subS..'...'..pCS..' F7')&#13;&#10;end&#13;&#10;--/******************COMPLETION CLEANUP********************/&#13;&#10;&#13;&#10;if iuCounter &gt;= uendLoop or _killtimer==1 then&#13;&#10;    timer:stopTimer(timerId)&#13;&#10;    upLoadArray={} --reset&#13;&#10;    iuCounter=0 -- reset&#13;&#10;    --&gt; enable for JD-990 panel mySetModValue(&quot;TRIGBULKDUMP&quot;,0,true)&#13;&#10;    c:setComponentValue (0, true) --&gt; percentage complete&#13;&#10;    c:setComponentText(&quot;Complete&quot;)&#13;&#10;&#13;&#10;    panel:getLabel(&quot;debugOutputLabel&quot;):setText('')&#13;&#10;    panel:getLabel(&quot;PROG&quot;):setText('')&#13;&#10;    panel:getComponent(&quot;RESETSWITCH&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0))&#13;&#10;    panel:getComponent(&quot;SAVETOFILE&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0))&#13;&#10;&#9;panel:getComponent(&quot;myBigDump&quot;):setPropertyString(&quot;componentDisabled&quot;,tostring(0))&#13;&#10;if _killtimer ~= 1 then&#13;&#10;smiley(&quot;sad&quot;,0)--hide sad face&#13;&#10;smiley(&quot;happy&quot;,1)--show happy face&#13;&#10;    _killtimer=0&#13;&#10;end&#13;&#10;end&#13;&#10;&#13;&#10;end&#13;&#10;&#13;&#10;&#13;&#10;end --function&#13;&#10;--------------------------------------------------------"
                   luaMethodLinkedProperty="" luaMethodSource="0" uuid="e5e1eae108ca48f2beaf62bab19218ed"
                   luaMethodValid="1"/>
        <luaMethod luaMethodName="helpWrapper" luaMethodCode="--&#10;-- Called when a mouse is down on this component&#10;--&#10;&#10;helpWrapper = function(--[[ CtrlrComponent --]] comp, --[[ MouseEvent --]] event)&#13;&#10; if panel:getBootstrapState() then&#13;&#10;        return&#13;&#10;    end&#13;&#10;&#9;if panel:getRestoreState() == true or panel:getProgramState() == true then&#13;&#10;&#9;&#9;return&#13;&#10;&#9;end&#13;&#10;myHelp()&#13;&#10;end --function&#13;&#10;---------------------------------------------------------"
                   luaMethodLinkedProperty="componentLuaMouseDown" luaMethodSource="0"
                   uuid="586debd7cece48aaaba46807fe4a214d" luaMethodValid="1"/>
      </luaMethodGroup>
      <luaMethod luaMethodName="Licence" luaMethodCode="function Licence()&#10;gpl=[[&#13;&#10;                    GNU GENERAL PUBLIC LICENSE&#13;&#10;                       Version 3, 29 June 2007&#13;&#10;&#13;&#10; Copyright (C) 2007 Free Software Foundation, Inc. &lt;https://fsf.org/&gt;&#13;&#10;]]&#13;&#10;gpl1=[[&#13;&#10; Everyone is permitted to copy and distribute verbatim copies&#13;&#10; of this license document, but changing it is not allowed.&#13;&#10;&#13;&#10;                            Preamble&#13;&#10;&#13;&#10;  The GNU General Public License is a free, copyleft license for&#13;&#10;software and other kinds of works.&#13;&#10;&#13;&#10;  The licenses for most software and other practical works are designed&#13;&#10;to take away your freedom to share and change the works.  By contrast,&#13;&#10;the GNU General Public License is intended to guarantee your freedom to&#13;&#10;share and change all versions of a program--to make sure it remains free&#13;&#10;software for all its users.  We, the Free Software Foundation, use the&#13;&#10;GNU General Public License for most of our software; it applies also to&#13;&#10;any other work released this way by its authors.  You can apply it to&#13;&#10;your programs, too.&#13;&#10;&#13;&#10;  When we speak of free software, we are referring to freedom, not&#13;&#10;price.  Our General Public Licenses are designed to make sure that you&#13;&#10;have the freedom to distribute copies of free software (and charge for&#13;&#10;them if you wish), that you receive source code or can get it if you&#13;&#10;want it, that you can change the software or use pieces of it in new&#13;&#10;free programs, and that you know you can do these things.&#13;&#10;&#13;&#10;  To protect your rights, we need to prevent others from denying you&#13;&#10;these rights or asking you to surrender the rights.  Therefore, you have&#13;&#10;certain responsibilities if you distribute copies of the software, or if&#13;&#10;you modify it: responsibilities to respect the freedom of others.&#13;&#10;&#13;&#10;  For example, if you distribute copies of such a program, whether&#13;&#10;gratis or for a fee, you must pass on to the recipients the same&#13;&#10;freedoms that you received.  You must make sure that they, too, receive&#13;&#10;or can get the source code.  And you must show them these terms so they&#13;&#10;know their rights.&#13;&#10;&#13;&#10;  Developers that use the GNU GPL protect your rights with two steps:&#13;&#10;(1) assert copyright on the software, and (2) offer you this License&#13;&#10;giving you legal permission to copy, distribute and/or modify it.&#13;&#10;&#13;&#10;  For the developers' and authors' protection, the GPL clearly explains&#13;&#10;that there is no warranty for this free software.  For both users' and&#13;&#10;authors' sake, the GPL requires that modified versions be marked as&#13;&#10;changed, so that their problems will not be attributed erroneously to&#13;&#10;authors of previous versions.&#13;&#10;&#13;&#10;  Some devices are designed to deny users access to install or run&#13;&#10;modified versions of the software inside them, although the manufacturer&#13;&#10;can do so.  This is fundamentally incompatible with the aim of&#13;&#10;protecting users' freedom to change the software.  The systematic&#13;&#10;pattern of such abuse occurs in the area of products for individuals to&#13;&#10;use, which is precisely where it is most unacceptable.  Therefore, we&#13;&#10;have designed this version of the GPL to prohibit the practice for those&#13;&#10;products.  If such problems arise substantially in other domains, we&#13;&#10;stand ready to extend this provision to those domains in future versions&#13;&#10;of the GPL, as needed to protect the freedom of users.&#13;&#10;&#13;&#10;  Finally, every program is threatened constantly by software patents.&#13;&#10;States should not allow patents to restrict development and use of&#13;&#10;software on general-purpose computers, but in those that do, we wish to&#13;&#10;avoid the special danger that patents applied to a free program could&#13;&#10;make it effectively proprietary.  To prevent this, the GPL assures that&#13;&#10;patents cannot be used to render the program non-free.&#13;&#10;&#13;&#10;  The precise terms and conditions for copying, distribution and&#13;&#10;modification follow.&#13;&#10;&#13;&#10;                       TERMS AND CONDITIONS&#13;&#10;&#13;&#10;  0. Definitions.&#13;&#10;&#13;&#10;  &quot;This License&quot; refers to version 3 of the GNU General Public License.&#13;&#10;&#13;&#10;  &quot;Copyright&quot; also means copyright-like laws that apply to other kinds of&#13;&#10;works, such as semiconductor masks.&#13;&#10;&#13;&#10;  &quot;The Program&quot; refers to any copyrightable work licensed under this&#13;&#10;License.  Each licensee is addressed as &quot;you&quot;.  &quot;Licensees&quot; and&#13;&#10;&quot;recipients&quot; may be individuals or organizations.&#13;&#10;&#13;&#10;  To &quot;modify&quot; a work means to copy from or adapt all or part of the work&#13;&#10;in a fashion requiring copyright permission, other than the making of an&#13;&#10;exact copy.  The resulting work is called a &quot;modified version&quot; of the&#13;&#10;earlier work or a work &quot;based on&quot; the earlier work.&#13;&#10;&#13;&#10;  A &quot;covered work&quot; means either the unmodified Program or a work based&#13;&#10;on the Program.&#13;&#10;&#13;&#10;  To &quot;propagate&quot; a work means to do anything with it that, without&#13;&#10;permission, would make you directly or secondarily liable for&#13;&#10;infringement under applicable copyright law, except executing it on a&#13;&#10;computer or modifying a private copy.  Propagation includes copying,&#13;&#10;distribution (with or without modification), making available to the&#13;&#10;public, and in some countries other activities as well.&#13;&#10;&#13;&#10;  To &quot;convey&quot; a work means any kind of propagation that enables other&#13;&#10;parties to make or receive copies.  Mere interaction with a user through&#13;&#10;a computer network, with no transfer of a copy, is not conveying.&#13;&#10;&#13;&#10;  An interactive user interface displays &quot;Appropriate Legal Notices&quot;&#13;&#10;to the extent that it includes a convenient and prominently visible&#13;&#10;feature that (1) displays an appropriate copyright notice, and (2)&#13;&#10;tells the user that there is no warranty for the work (except to the&#13;&#10;extent that warranties are provided), that licensees may convey the&#13;&#10;work under this License, and how to view a copy of this License.  If&#13;&#10;the interface presents a list of user commands or options, such as a&#13;&#10;menu, a prominent item in the list meets this criterion.&#13;&#10;&#13;&#10;  1. Source Code.&#13;&#10;&#13;&#10;  The &quot;source code&quot; for a work means the preferred form of the work&#13;&#10;for making modifications to it.  &quot;Object code&quot; means any non-source&#13;&#10;form of a work.&#13;&#10;&#13;&#10;  A &quot;Standard Interface&quot; means an interface that either is an official&#13;&#10;standard defined by a recognized standards body, or, in the case of&#13;&#10;interfaces specified for a particular programming language, one that&#13;&#10;is widely used among developers working in that language.&#13;&#10;&#13;&#10;  The &quot;System Libraries&quot; of an executable work include anything, other&#13;&#10;than the work as a whole, that (a) is included in the normal form of&#13;&#10;packaging a Major Component, but which is not part of that Major&#13;&#10;Component, and (b) serves only to enable use of the work with that&#13;&#10;Major Component, or to implement a Standard Interface for which an&#13;&#10;implementation is available to the public in source code form.  A&#13;&#10;&quot;Major Component&quot;, in this context, means a major essential component&#13;&#10;(kernel, window system, and so on) of the specific operating system&#13;&#10;(if any) on which the executable work runs, or a compiler used to&#13;&#10;produce the work, or an object code interpreter used to run it.&#13;&#10;&#13;&#10;  The &quot;Corresponding Source&quot; for a work in object code form means all&#13;&#10;the source code needed to generate, install, and (for an executable&#13;&#10;work) run the object code and to modify the work, including scripts to&#13;&#10;control those activities.  However, it does not include the work's&#13;&#10;System Libraries, or general-purpose tools or generally available free&#13;&#10;programs which are used unmodified in performing those activities but&#13;&#10;which are not part of the work.  For example, Corresponding Source&#13;&#10;includes interface definition files associated with source files for&#13;&#10;the work, and the source code for shared libraries and dynamically&#13;&#10;linked subprograms that the work is specifically designed to require,&#13;&#10;such as by intimate data communication or control flow between those&#13;&#10;subprograms and other parts of the work.&#13;&#10;&#13;&#10;  The Corresponding Source need not include anything that users&#13;&#10;can regenerate automatically from other parts of the Corresponding&#13;&#10;Source.&#13;&#10;&#13;&#10;  The Corresponding Source for a work in source code form is that&#13;&#10;same work.&#13;&#10;&#13;&#10;  2. Basic Permissions.&#13;&#10;&#13;&#10;  All rights granted under this License are granted for the term of&#13;&#10;copyright on the Program, and are irrevocable provided the stated&#13;&#10;conditions are met.  This License explicitly affirms your unlimited&#13;&#10;permission to run the unmodified Program.  The output from running a&#13;&#10;covered work is covered by this License only if the output, given its&#13;&#10;content, constitutes a covered work.  This License acknowledges your&#13;&#10;rights of fair use or other equivalent, as provided by copyright law.&#13;&#10;&#13;&#10;  You may make, run and propagate covered works that you do not&#13;&#10;convey, without conditions so long as your license otherwise remains&#13;&#10;in force.  You may convey covered works to others for the sole purpose&#13;&#10;of having them make modifications exclusively for you, or provide you&#13;&#10;with facilities for running those works, provided that you comply with&#13;&#10;the terms of this License in conveying all material for which you do&#13;&#10;not control copyright.  Those thus making or running the covered works&#13;&#10;for you must do so exclusively on your behalf, under your direction&#13;&#10;and control, on terms that prohibit them from making any copies of&#13;&#10;your copyrighted material outside their relationship with you.&#13;&#10;&#13;&#10;  Conveying under any other circumstances is permitted solely under&#13;&#10;the conditions stated below.  Sublicensing is not allowed; section 10&#13;&#10;makes it unnecessary.&#13;&#10;&#13;&#10;  3. Protecting Users' Legal Rights From Anti-Circumvention Law.&#13;&#10;&#13;&#10;  No covered work shall be deemed part of an effective technological&#13;&#10;measure under any applicable law fulfilling obligations under article&#13;&#10;11 of the WIPO copyright treaty adopted on 20 December 1996, or&#13;&#10;similar laws prohibiting or restricting circumvention of such&#13;&#10;measures.&#13;&#10;&#13;&#10;  When you convey a covered work, you waive any legal power to forbid&#13;&#10;circumvention of technological measures to the extent such circumvention&#13;&#10;is effected by exercising rights under this License with respect to&#13;&#10;the covered work, and you disclaim any intention to limit operation or&#13;&#10;modification of the work as a means of enforcing, against the work's&#13;&#10;users, your or third parties' legal rights to forbid circumvention of&#13;&#10;technological measures.&#13;&#10;&#13;&#10;  4. Conveying Verbatim Copies.&#13;&#10;&#13;&#10;  You may convey verbatim copies of the Program's source code as you&#13;&#10;receive it, in any medium, provided that you conspicuously and&#13;&#10;appropriately publish on each copy an appropriate copyright notice;&#13;&#10;keep intact all notices stating that this License and any&#13;&#10;non-permissive terms added in accord with section 7 apply to the code;&#13;&#10;keep intact all notices of the absence of any warranty; and give all&#13;&#10;recipients a copy of this License along with the Program.&#13;&#10;&#13;&#10;  You may charge any price or no price for each copy that you convey,&#13;&#10;and you may offer support or warranty protection for a fee.&#13;&#10;&#13;&#10;  5. Conveying Modified Source Versions.&#13;&#10;&#13;&#10;  You may convey a work based on the Program, or the modifications to&#13;&#10;produce it from the Program, in the form of source code under the&#13;&#10;terms of section 4, provided that you also meet all of these conditions:&#13;&#10;&#13;&#10;    a) The work must carry prominent notices stating that you modified&#13;&#10;    it, and giving a relevant date.&#13;&#10;&#13;&#10;    b) The work must carry prominent notices stating that it is&#13;&#10;    released under this License and any conditions added under section&#13;&#10;    7.  This requirement modifies the requirement in section 4 to&#13;&#10;    &quot;keep intact all notices&quot;.&#13;&#10;&#13;&#10;    c) You must license the entire work, as a whole, under this&#13;&#10;    License to anyone who comes into possession of a copy.  This&#13;&#10;    License will therefore apply, along with any applicable section 7&#13;&#10;    additional terms, to the whole of the work, and all its parts,&#13;&#10;    regardless of how they are packaged.  This License gives no&#13;&#10;    permission to license the work in any other way, but it does not&#13;&#10;    invalidate such permission if you have separately received it.&#13;&#10;&#13;&#10;    d) If the work has interactive user interfaces, each must display&#13;&#10;    Appropriate Legal Notices; however, if the Program has interactive&#13;&#10;    interfaces that do not display Appropriate Legal Notices, your&#13;&#10;    work need not make them do so.&#13;&#10;&#13;&#10;  A compilation of a covered work with other separate and independent&#13;&#10;works, which are not by their nature extensions of the covered work,&#13;&#10;and which are not combined with it such as to form a larger program,&#13;&#10;in or on a volume of a storage or distribution medium, is called an&#13;&#10;&quot;aggregate&quot; if the compilation and its resulting copyright are not&#13;&#10;used to limit the access or legal rights of the compilation's users&#13;&#10;beyond what the individual works permit.  Inclusion of a covered work&#13;&#10;in an aggregate does not cause this License to apply to the other&#13;&#10;parts of the aggregate.&#13;&#10;&#13;&#10;  6. Conveying Non-Source Forms.&#13;&#10;&#13;&#10;  You may convey a covered work in object code form under the terms&#13;&#10;of sections 4 and 5, provided that you also convey the&#13;&#10;machine-readable Corresponding Source under the terms of this License,&#13;&#10;in one of these ways:&#13;&#10;&#13;&#10;    a) Convey the object code in, or embodied in, a physical product&#13;&#10;    (including a physical distribution medium), accompanied by the&#13;&#10;    Corresponding Source fixed on a durable physical medium&#13;&#10;    customarily used for software interchange.&#13;&#10;&#13;&#10;    b) Convey the object code in, or embodied in, a physical product&#13;&#10;    (including a physical distribution medium), accompanied by a&#13;&#10;    written offer, valid for at least three years and valid for as&#13;&#10;    long as you offer spare parts or customer support for that product&#13;&#10;    model, to give anyone who possesses the object code either (1) a&#13;&#10;    copy of the Corresponding Source for all the software in the&#13;&#10;    product that is covered by this License, on a durable physical&#13;&#10;    medium customarily used for software interchange, for a price no&#13;&#10;    more than your reasonable cost of physically performing this&#13;&#10;    conveying of source, or (2) access to copy the&#13;&#10;    Corresponding Source from a network server at no charge.&#13;&#10;&#13;&#10;    c) Convey individual copies of the object code with a copy of the&#13;&#10;    written offer to provide the Corresponding Source.  This&#13;&#10;    alternative is allowed only occasionally and noncommercially, and&#13;&#10;    only if you received the object code with such an offer, in accord&#13;&#10;    with subsection 6b.&#13;&#10;&#13;&#10;    d) Convey the object code by offering access from a designated&#13;&#10;    place (gratis or for a charge), and offer equivalent access to the&#13;&#10;    Corresponding Source in the same way through the same place at no&#13;&#10;    further charge.  You need not require recipients to copy the&#13;&#10;    Corresponding Source along with the object code.  If the place to&#13;&#10;    copy the object code is a network server, the Corresponding Source&#13;&#10;    may be on a different server (operated by you or a third party)&#13;&#10;    that supports equivalent copying facilities, provided you maintain&#13;&#10;    clear directions next to the object code saying where to find the&#13;&#10;    Corresponding Source.  Regardless of what server hosts the&#13;&#10;    Corresponding Source, you remain obligated to ensure that it is&#13;&#10;    available for as long as needed to satisfy these requirements.&#13;&#10;&#13;&#10;    e) Convey the object code using peer-to-peer transmission, provided&#13;&#10;    you inform other peers where the object code and Corresponding&#13;&#10;    Source of the work are being offered to the general public at no&#13;&#10;    charge under subsection 6d.&#13;&#10;&#13;&#10;  A separable portion of the object code, whose source code is excluded&#13;&#10;from the Corresponding Source as a System Library, need not be&#13;&#10;included in conveying the object code work.&#13;&#10;&#13;&#10;  A &quot;User Product&quot; is either (1) a &quot;consumer product&quot;, which means any&#13;&#10;tangible personal property which is normally used for personal, family,&#13;&#10;or household purposes, or (2) anything designed or sold for incorporation&#13;&#10;into a dwelling.  In determining whether a product is a consumer product,&#13;&#10;doubtful cases shall be resolved in favor of coverage.  For a particular&#13;&#10;product received by a particular user, &quot;normally used&quot; refers to a&#13;&#10;typical or common use of that class of product, regardless of the status&#13;&#10;of the particular user or of the way in which the particular user&#13;&#10;actually uses, or expects or is expected to use, the product.  A product&#13;&#10;is a consumer product regardless of whether the product has substantial&#13;&#10;commercial, industrial or non-consumer uses, unless such uses represent&#13;&#10;the only significant mode of use of the product.&#13;&#10;&#13;&#10;  &quot;Installation Information&quot; for a User Product means any methods,&#13;&#10;procedures, authorization keys, or other information required to install&#13;&#10;and execute modified versions of a covered work in that User Product from&#13;&#10;a modified version of its Corresponding Source.  The information must&#13;&#10;suffice to ensure that the continued functioning of the modified object&#13;&#10;code is in no case prevented or interfered with solely because&#13;&#10;modification has been made.&#13;&#10;&#13;&#10;  If you convey an object code work under this section in, or with, or&#13;&#10;specifically for use in, a User Product, and the conveying occurs as&#13;&#10;part of a transaction in which the right of possession and use of the&#13;&#10;User Product is transferred to the recipient in perpetuity or for a&#13;&#10;fixed term (regardless of how the transaction is characterized), the&#13;&#10;Corresponding Source conveyed under this section must be accompanied&#13;&#10;by the Installation Information.  But this requirement does not apply&#13;&#10;if neither you nor any third party retains the ability to install&#13;&#10;modified object code on the User Product (for example, the work has&#13;&#10;been installed in ROM).&#13;&#10;&#13;&#10;  The requirement to provide Installation Information does not include a&#13;&#10;requirement to continue to provide support service, warranty, or updates&#13;&#10;for a work that has been modified or installed by the recipient, or for&#13;&#10;the User Product in which it has been modified or installed.  Access to a&#13;&#10;network may be denied when the modification itself materially and&#13;&#10;adversely affects the operation of the network or violates the rules and&#13;&#10;protocols for communication across the network.&#13;&#10;&#13;&#10;  Corresponding Source conveyed, and Installation Information provided,&#13;&#10;in accord with this section must be in a format that is publicly&#13;&#10;documented (and with an implementation available to the public in&#13;&#10;source code form), and must require no special password or key for&#13;&#10;unpacking, reading or copying.&#13;&#10;&#13;&#10;  7. Additional Terms.&#13;&#10;&#13;&#10;  &quot;Additional permissions&quot; are terms that supplement the terms of this&#13;&#10;License by making exceptions from one or more of its conditions.&#13;&#10;Additional permissions that are applicable to the entire Program shall&#13;&#10;be treated as though they were included in this License, to the extent&#13;&#10;that they are valid under applicable law.  If additional permissions&#13;&#10;apply only to part of the Program, that part may be used separately&#13;&#10;under those permissions, but the entire Program remains governed by&#13;&#10;this License without regard to the additional permissions.&#13;&#10;&#13;&#10;  When you convey a copy of a covered work, you may at your option&#13;&#10;remove any additional permissions from that copy, or from any part of&#13;&#10;it.  (Additional permissions may be written to require their own&#13;&#10;removal in certain cases when you modify the work.)  You may place&#13;&#10;additional permissions on material, added by you to a covered work,&#13;&#10;for which you have or can give appropriate copyright permission.&#13;&#10;&#13;&#10;  Notwithstanding any other provision of this License, for material you&#13;&#10;add to a covered work, you may (if authorized by the copyright holders of&#13;&#10;that material) supplement the terms of this License with terms:&#13;&#10;&#13;&#10;    a) Disclaiming warranty or limiting liability differently from the&#13;&#10;    terms of sections 15 and 16 of this License; or&#13;&#10;&#13;&#10;    b) Requiring preservation of specified reasonable legal notices or&#13;&#10;    author attributions in that material or in the Appropriate Legal&#13;&#10;    Notices displayed by works containing it; or&#13;&#10;&#13;&#10;    c) Prohibiting misrepresentation of the origin of that material, or&#13;&#10;    requiring that modified versions of such material be marked in&#13;&#10;    reasonable ways as different from the original version; or&#13;&#10;&#13;&#10;    d) Limiting the use for publicity purposes of names of licensors or&#13;&#10;    authors of the material; or&#13;&#10;&#13;&#10;    e) Declining to grant rights under trademark law for use of some&#13;&#10;    trade names, trademarks, or service marks; or&#13;&#10;&#13;&#10;    f) Requiring indemnification of licensors and authors of that&#13;&#10;    material by anyone who conveys the material (or modified versions of&#13;&#10;    it) with contractual assumptions of liability to the recipient, for&#13;&#10;    any liability that these contractual assumptions directly impose on&#13;&#10;    those licensors and authors.&#13;&#10;&#13;&#10;  All other non-permissive additional terms are considered &quot;further&#13;&#10;restrictions&quot; within the meaning of section 10.  If the Program as you&#13;&#10;received it, or any part of it, contains a notice stating that it is&#13;&#10;governed by this License along with a term that is a further&#13;&#10;restriction, you may remove that term.  If a license document contains&#13;&#10;a further restriction but permits relicensing or conveying under this&#13;&#10;License, you may add to a covered work material governed by the terms&#13;&#10;of that license document, provided that the further restriction does&#13;&#10;not survive such relicensing or conveying.&#13;&#10;&#13;&#10;  If you add terms to a covered work in accord with this section, you&#13;&#10;must place, in the relevant source files, a statement of the&#13;&#10;additional terms that apply to those files, or a notice indicating&#13;&#10;where to find the applicable terms.&#13;&#10;&#13;&#10;  Additional terms, permissive or non-permissive, may be stated in the&#13;&#10;form of a separately written license, or stated as exceptions;&#13;&#10;the above requirements apply either way.&#13;&#10;&#13;&#10;  8. Termination.&#13;&#10;&#13;&#10;  You may not propagate or modify a covered work except as expressly&#13;&#10;provided under this License.  Any attempt otherwise to propagate or&#13;&#10;modify it is void, and will automatically terminate your rights under&#13;&#10;this License (including any patent licenses granted under the third&#13;&#10;paragraph of section 11).&#13;&#10;&#13;&#10;  However, if you cease all violation of this License, then your&#13;&#10;license from a particular copyright holder is reinstated (a)&#13;&#10;provisionally, unless and until the copyright holder explicitly and&#13;&#10;finally terminates your license, and (b) permanently, if the copyright&#13;&#10;holder fails to notify you of the violation by some reasonable means&#13;&#10;prior to 60 days after the cessation.&#13;&#10;&#13;&#10;  Moreover, your license from a particular copyright holder is&#13;&#10;reinstated permanently if the copyright holder notifies you of the&#13;&#10;violation by some reasonable means, this is the first time you have&#13;&#10;received notice of violation of this License (for any work) from that&#13;&#10;copyright holder, and you cure the violation prior to 30 days after&#13;&#10;your receipt of the notice.&#13;&#10;&#13;&#10;  Termination of your rights under this section does not terminate the&#13;&#10;licenses of parties who have received copies or rights from you under&#13;&#10;this License.  If your rights have been terminated and not permanently&#13;&#10;reinstated, you do not qualify to receive new licenses for the same&#13;&#10;material under section 10.&#13;&#10;&#13;&#10;  9. Acceptance Not Required for Having Copies.&#13;&#10;&#13;&#10;  You are not required to accept this License in order to receive or&#13;&#10;run a copy of the Program.  Ancillary propagation of a covered work&#13;&#10;occurring solely as a consequence of using peer-to-peer transmission&#13;&#10;to receive a copy likewise does not require acceptance.  However,&#13;&#10;nothing other than this License grants you permission to propagate or&#13;&#10;modify any covered work.  These actions infringe copyright if you do&#13;&#10;not accept this License.  Therefore, by modifying or propagating a&#13;&#10;covered work, you indicate your acceptance of this License to do so.&#13;&#10;&#13;&#10;  10. Automatic Licensing of Downstream Recipients.&#13;&#10;&#13;&#10;  Each time you convey a covered work, the recipient automatically&#13;&#10;receives a license from the original licensors, to run, modify and&#13;&#10;propagate that work, subject to this License.  You are not responsible&#13;&#10;for enforcing compliance by third parties with this License.&#13;&#10;&#13;&#10;  An &quot;entity transaction&quot; is a transaction transferring control of an&#13;&#10;organization, or substantially all assets of one, or subdividing an&#13;&#10;organization, or merging organizations.  If propagation of a covered&#13;&#10;work results from an entity transaction, each party to that&#13;&#10;transaction who receives a copy of the work also receives whatever&#13;&#10;licenses to the work the party's predecessor in interest had or could&#13;&#10;give under the previous paragraph, plus a right to possession of the&#13;&#10;Corresponding Source of the work from the predecessor in interest, if&#13;&#10;the predecessor has it or can get it with reasonable efforts.&#13;&#10;&#13;&#10;  You may not impose any further restrictions on the exercise of the&#13;&#10;rights granted or affirmed under this License.  For example, you may&#13;&#10;not impose a license fee, royalty, or other charge for exercise of&#13;&#10;rights granted under this License, and you may not initiate litigation&#13;&#10;(including a cross-claim or counterclaim in a lawsuit) alleging that&#13;&#10;any patent claim is infringed by making, using, selling, offering for&#13;&#10;sale, or importing the Program or any portion of it.&#13;&#10;&#13;&#10;  11. Patents.&#13;&#10;&#13;&#10;  A &quot;contributor&quot; is a copyright holder who authorizes use under this&#13;&#10;License of the Program or a work on which the Program is based.  The&#13;&#10;work thus licensed is called the contributor's &quot;contributor version&quot;.&#13;&#10;&#13;&#10;  A contributor's &quot;essential patent claims&quot; are all patent claims&#13;&#10;owned or controlled by the contributor, whether already acquired or&#13;&#10;hereafter acquired, that would be infringed by some manner, permitted&#13;&#10;by this License, of making, using, or selling its contributor version,&#13;&#10;but do not include claims that would be infringed only as a&#13;&#10;consequence of further modification of the contributor version.  For&#13;&#10;purposes of this definition, &quot;control&quot; includes the right to grant&#13;&#10;patent sublicenses in a manner consistent with the requirements of&#13;&#10;this License.&#13;&#10;&#13;&#10;  Each contributor grants you a non-exclusive, worldwide, royalty-free&#13;&#10;patent license under the contributor's essential patent claims, to&#13;&#10;make, use, sell, offer for sale, import and otherwise run, modify and&#13;&#10;propagate the contents of its contributor version.&#13;&#10;&#13;&#10;  In the following three paragraphs, a &quot;patent license&quot; is any express&#13;&#10;agreement or commitment, however denominated, not to enforce a patent&#13;&#10;(such as an express permission to practice a patent or covenant not to&#13;&#10;sue for patent infringement).  To &quot;grant&quot; such a patent license to a&#13;&#10;party means to make such an agreement or commitment not to enforce a&#13;&#10;patent against the party.&#13;&#10;&#13;&#10;  If you convey a covered work, knowingly relying on a patent license,&#13;&#10;and the Corresponding Source of the work is not available for anyone&#13;&#10;to copy, free of charge and under the terms of this License, through a&#13;&#10;publicly available network server or other readily accessible means,&#13;&#10;then you must either (1) cause the Corresponding Source to be so&#13;&#10;available, or (2) arrange to deprive yourself of the benefit of the&#13;&#10;patent license for this particular work, or (3) arrange, in a manner&#13;&#10;consistent with the requirements of this License, to extend the patent&#13;&#10;license to downstream recipients.  &quot;Knowingly relying&quot; means you have&#13;&#10;actual knowledge that, but for the patent license, your conveying the&#13;&#10;covered work in a country, or your recipient's use of the covered work&#13;&#10;in a country, would infringe one or more identifiable patents in that&#13;&#10;country that you have reason to believe are valid.&#13;&#10;&#13;&#10;  If, pursuant to or in connection with a single transaction or&#13;&#10;arrangement, you convey, or propagate by procuring conveyance of, a&#13;&#10;covered work, and grant a patent license to some of the parties&#13;&#10;receiving the covered work authorizing them to use, propagate, modify&#13;&#10;or convey a specific copy of the covered work, then the patent license&#13;&#10;you grant is automatically extended to all recipients of the covered&#13;&#10;work and works based on it.&#13;&#10;&#13;&#10;  A patent license is &quot;discriminatory&quot; if it does not include within&#13;&#10;the scope of its coverage, prohibits the exercise of, or is&#13;&#10;conditioned on the non-exercise of one or more of the rights that are&#13;&#10;specifically granted under this License.  You may not convey a covered&#13;&#10;work if you are a party to an arrangement with a third party that is&#13;&#10;in the business of distributing software, under which you make payment&#13;&#10;to the third party based on the extent of your activity of conveying&#13;&#10;the work, and under which the third party grants, to any of the&#13;&#10;parties who would receive the covered work from you, a discriminatory&#13;&#10;patent license (a) in connection with copies of the covered work&#13;&#10;conveyed by you (or copies made from those copies), or (b) primarily&#13;&#10;for and in connection with specific products or compilations that&#13;&#10;contain the covered work, unless you entered into that arrangement,&#13;&#10;or that patent license was granted, prior to 28 March 2007.&#13;&#10;&#13;&#10;  Nothing in this License shall be construed as excluding or limiting&#13;&#10;any implied license or other defenses to infringement that may&#13;&#10;otherwise be available to you under applicable patent law.&#13;&#10;&#13;&#10;  12. No Surrender of Others' Freedom.&#13;&#10;&#13;&#10;  If conditions are imposed on you (whether by court order, agreement or&#13;&#10;otherwise) that contradict the conditions of this License, they do not&#13;&#10;excuse you from the conditions of this License.  If you cannot convey a&#13;&#10;covered work so as to satisfy simultaneously your obligations under this&#13;&#10;License and any other pertinent obligations, then as a consequence you may&#13;&#10;not convey it at all.  For example, if you agree to terms that obligate you&#13;&#10;to collect a royalty for further conveying from those to whom you convey&#13;&#10;the Program, the only way you could satisfy both those terms and this&#13;&#10;License would be to refrain entirely from conveying the Program.&#13;&#10;&#13;&#10;  13. Use with the GNU Affero General Public License.&#13;&#10;&#13;&#10;  Notwithstanding any other provision of this License, you have&#13;&#10;permission to link or combine any covered work with a work licensed&#13;&#10;under version 3 of the GNU Affero General Public License into a single&#13;&#10;combined work, and to convey the resulting work.  The terms of this&#13;&#10;License will continue to apply to the part which is the covered work,&#13;&#10;but the special requirements of the GNU Affero General Public License,&#13;&#10;section 13, concerning interaction through a network will apply to the&#13;&#10;combination as such.&#13;&#10;&#13;&#10;  14. Revised Versions of this License.&#13;&#10;&#13;&#10;  The Free Software Foundation may publish revised and/or new versions of&#13;&#10;the GNU General Public License from time to time.  Such new versions will&#13;&#10;be similar in spirit to the present version, but may differ in detail to&#13;&#10;address new problems or concerns.&#13;&#10;&#13;&#10;  Each version is given a distinguishing version number.  If the&#13;&#10;Program specifies that a certain numbered version of the GNU General&#13;&#10;Public License &quot;or any later version&quot; applies to it, you have the&#13;&#10;option of following the terms and conditions either of that numbered&#13;&#10;version or of any later version published by the Free Software&#13;&#10;Foundation.  If the Program does not specify a version number of the&#13;&#10;GNU General Public License, you may choose any version ever published&#13;&#10;by the Free Software Foundation.&#13;&#10;&#13;&#10;  If the Program specifies that a proxy can decide which future&#13;&#10;versions of the GNU General Public License can be used, that proxy's&#13;&#10;public statement of acceptance of a version permanently authorizes you&#13;&#10;to choose that version for the Program.&#13;&#10;&#13;&#10;  Later license versions may give you additional or different&#13;&#10;permissions.  However, no additional obligations are imposed on any&#13;&#10;author or copyright holder as a result of your choosing to follow a&#13;&#10;later version.&#13;&#10;&#13;&#10;  15. Disclaimer of Warranty.&#13;&#10;&#13;&#10;  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY&#13;&#10;APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT&#13;&#10;HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY&#13;&#10;OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,&#13;&#10;THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR&#13;&#10;PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM&#13;&#10;IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF&#13;&#10;ALL NECESSARY SERVICING, REPAIR OR CORRECTION.&#13;&#10;&#13;&#10;  16. Limitation of Liability.&#13;&#10;&#13;&#10;  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING&#13;&#10;WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS&#13;&#10;THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY&#13;&#10;GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE&#13;&#10;USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF&#13;&#10;DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD&#13;&#10;PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),&#13;&#10;EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF&#13;&#10;SUCH DAMAGES.&#13;&#10;&#13;&#10;  17. Interpretation of Sections 15 and 16.&#13;&#10;&#13;&#10;  If the disclaimer of warranty and limitation of liability provided&#13;&#10;above cannot be given local legal effect according to their terms,&#13;&#10;reviewing courts shall apply local law that most closely approximates&#13;&#10;an absolute waiver of all civil liability in connection with the&#13;&#10;Program, unless a warranty or assumption of liability accompanies a&#13;&#10;copy of the Program in return for a fee.&#13;&#10;&#13;&#10;                     END OF TERMS AND CONDITIONS&#13;&#10;&#13;&#10;            How to Apply These Terms to Your New Programs&#13;&#10;&#13;&#10;  If you develop a new program, and you want it to be of the greatest&#13;&#10;possible use to the public, the best way to achieve this is to make it&#13;&#10;free software which everyone can redistribute and change under these terms.&#13;&#10;&#13;&#10;  To do so, attach the following notices to the program.  It is safest&#13;&#10;to attach them to the start of each source file to most effectively&#13;&#10;state the exclusion of warranty; and each file should have at least&#13;&#10;the &quot;copyright&quot; line and a pointer to where the full notice is found.&#13;&#10;&#13;&#10;    &lt;one line to give the program's name and a brief idea of what it does.&gt;&#13;&#10;    Copyright (C) &lt;year&gt;  &lt;name of author&gt;&#13;&#10;&#13;&#10;    This program is free software: you can redistribute it and/or modify&#13;&#10;    it under the terms of the GNU General Public License as published by&#13;&#10;    the Free Software Foundation, either version 3 of the License, or&#13;&#10;    (at your option) any later version.&#13;&#10;&#13;&#10;    This program is distributed in the hope that it will be useful,&#13;&#10;    but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;&#10;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;&#10;    GNU General Public License for more details.&#13;&#10;&#13;&#10;    You should have received a copy of the GNU General Public License&#13;&#10;    along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.&#13;&#10;&#13;&#10;Also add information on how to contact you by electronic and paper mail.&#13;&#10;&#13;&#10;  If the program does terminal interaction, make it output a short&#13;&#10;notice like this when it starts in an interactive mode:&#13;&#10;&#13;&#10;    &lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;&#13;&#10;    This program comes with ABSOLUTELY NO WARRANTY; for details type &#96;show w'.&#13;&#10;    This is free software, and you are welcome to redistribute it&#13;&#10;    under certain conditions; type &#96;show c' for details.&#13;&#10;&#13;&#10;The hypothetical commands &#96;show w' and &#96;show c' should show the appropriate&#13;&#10;parts of the General Public License.  Of course, your program's commands&#13;&#10;might be different; for a GUI interface, you would use an &quot;about box&quot;.&#13;&#10;&#13;&#10;  You should also get your employer (if you work as a programmer) or school,&#13;&#10;if any, to sign a &quot;copyright disclaimer&quot; for the program, if necessary.&#13;&#10;For more information on this, and how to apply and follow the GNU GPL, see&#13;&#10;&lt;https://www.gnu.org/licenses/&gt;.&#13;&#10;&#13;&#10;  The GNU General Public License does not permit incorporating your program&#13;&#10;into proprietary programs.  If your program is a subroutine library, you&#13;&#10;may consider it more useful to permit linking proprietary applications with&#13;&#10;the library.  If this is what you want to do, use the GNU Lesser General&#13;&#10;Public License instead of this License.  But first, please read&#13;&#10;&lt;https://www.gnu.org/licenses/why-not-lgpl.html&gt;.&#13;&#10;]]&#13;&#10;end --function&#13;&#10;--------------------------------------------------------&#10;"
                 luaMethodLinkedProperty="" luaMethodSource="0" uuid="587c85b4d0fc4c34bd2ab36896eb78fa"
                 luaMethodValid="1"/>
    </luaManagerMethods>
  </luaManager>
  <panelResources>
    <resource resourceHash="-6785872134997316813" resourceLoadedTime="1588682693156"
              resourceSize="426" resourceFile="down_arrow.png" resourceSourceFile="D:\IR\Ctrlr_panels\resources\down_arrow.png"
              resourceName="down_arrow" resourceType="Image"/>
    <resource resourceHash="370070101145926101" resourceLoadedTime="1588682693156"
              resourceSize="2273" resourceFile="dream33216.png" resourceSourceFile="D:\IR\Ctrlr_panels\resources\dream33216.png"
              resourceName="dream33216" resourceType="Image"/>
    <resource resourceHash="-9140119530464839350" resourceLoadedTime="1588682693156"
              resourceSize="1895" resourceFile="dream_done33216.png" resourceSourceFile="D:\IR\Ctrlr_panels\resources\dream_done33216.png"
              resourceName="dream_done33216" resourceType="Image"/>
    <resource resourceHash="-4951204111249650182" resourceLoadedTime="1588682693156"
              resourceSize="1027" resourceFile="JD-990_logo.png" resourceSourceFile="D:\IR\Ctrlr_panels\resources\JD-990_logo.png"
              resourceName="JD-990_logo" resourceType="Image"/>
    <resource resourceHash="2868332275509158035" resourceLoadedTime="1588682693156"
              resourceSize="942" resourceFile="JV1010_GenericButton.png" resourceSourceFile="D:\IR\Ctrlr_panels\resources\JV1010_GenericButton.png"
              resourceName="JV1010_GenericButton" resourceType="Image"/>
    <resource resourceHash="5953972112633784083" resourceLoadedTime="1588682693156"
              resourceSize="1195" resourceFile="JV1010_GenericToneChange.png"
              resourceSourceFile="D:\IR\Ctrlr_panels\resources\JV1010_GenericToneChange.png"
              resourceName="JV1010_GenericToneChange" resourceType="Image"/>
    <resource resourceHash="761008335537720060" resourceLoadedTime="1588682693156"
              resourceSize="1182" resourceFile="smiley.png" resourceSourceFile="C:\Users\zan64\Dropbox\smiley.png"
              resourceName="smiley" resourceType="Image"/>
    <resource resourceHash="3074706775754906606" resourceLoadedTime="1588682693156"
              resourceSize="1112" resourceFile="smileyn.png" resourceSourceFile="C:\Users\zan64\Dropbox\smileyn.png"
              resourceName="smileyn" resourceType="Image"/>
  </panelResources>
  <uiPanelEditor uiPanelCanvasRectangle="0 0 640 380" uiPanelSnapSize="8" uiPanelBackgroundColour="0xffffffff"
                 uiPanelBackgroundColour1="ffd7d7d7" uiPanelBackgroundColour2="0xffffffff"
                 uiPanelBackgroundGradientType="0" uiPanelImageResource="-- None"
                 uiPanelEditMode="0" uiPanelLock="0" uiPanelDisabledOnEdit="0"
                 uiPanelMenuBarVisible="1" uiPanelMenuBarHideOnExport="0" uiPanelWidth=""
                 uiPanelHeight="" name="JD-990 Sysex Dump Utility" uiPanelImageAlpha="255"
                 uiPanelImageLayout="64" uiPanelSnapActive="1" uiPanelPropertiesOnRight="0"
                 luaPanelPaintBackground="-- None" luaPanelResized="-- None" luaPanelFileDragDropHandler="-- None"
                 luaPanelFileDragEnterHandler="-- None" luaPanelFileDragExitHandler="-- None"
                 uiPanelInvisibleComponentAlpha="0.5" uiPanelTooltipBackgroundColour="0xffeeeebb"
                 uiPanelTooltipOutlineColour="0xff000000" uiPanelTooltipColour="0xff000000"
                 uiPanelTooltipCornerRound="1" uiPanelTooltipPlacement="2" uiPanelTooltipFont="&lt;Sans-Serif&gt;;15;1;0;0;0;1;3"
                 uiPanelZoom="1" uiPanelPropertiesSize="246" uiPanelViewPortSize="986">
    <uiPanelCanvasLayer uiPanelCanvasLayerName="New layer" uiPanelCanvasLayerUid="e29182f001000000feffffffffffffff"
                        uiPanelCanvasLayerColour="0x000000" uiPanelCanvasLayerVisibility="1"
                        uiPanelCanvasLayerIndex="1"/>
    <uiPanelCanvasLayer uiPanelCanvasLayerName="Hidden" uiPanelCanvasLayerUid="250bf00f03000000feffffffffffffff"
                        uiPanelCanvasLayerColour="0x000000" uiPanelCanvasLayerVisibility="0"
                        uiPanelCanvasLayerIndex="0"/>
  </uiPanelEditor>
  <modulator modulatorVstExported="1" modulatorMax="1" vstIndex="2391" modulatorIsStatic="0"
             modulatorGlobalVariable="-1" modulatorMuteOnStart="0" modulatorMute="0"
             modulatorExcludeFromSnapshot="0" modulatorValueExpression="modulatorValue"
             modulatorValueExpressionReverse="midiValue" modulatorControllerExpression="value"
             luaModulatorGetValueForMIDI="-- None" luaModulatorGetValueFromMIDI="-- None"
             modulatorLinkedToPanelProperty="-- None" modulatorLinkedToModulatorProperty="-- None"
             modulatorLinkedToModulator="-- None" modulatorLinkedToModulatorSource="1"
             modulatorLinkedToComponent="Modulator" modulatorBaseValue="0"
             modulatorCustomIndex="0" modulatorCustomName="" modulatorCustomIndexGroup="0"
             modulatorCustomNameGroup="" modulatorVstNameFormat="%n" luaModulatorValueChange="downloadSysex"
             name="myBigDump" modulatorMin="0" modulatorValue="0">
    <midi midiMessageType="9" midiMessageChannelOverride="0" midiMessageChannel="1"
          midiMessageCtrlrNumber="1" midiMessageCtrlrValue="0" midiMessageMultiList=""
          midiMessageSysExFormula=""/>
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="1"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="DOWNLOAD FROM JD-990"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiImageButtonMode="1"
               uiImageButtonResource="JV1010_GenericToneChange" componentRectangle="496 32 118 40"
               resourceImageWidth="64" resourceImageHeight="24" resourceImagePaintMode="36"
               resourceImageOrientation="1" uiImageButtonTextColour="0xff000000"
               uiImageButtonContent="False&#10;True" uiImageButtonTextPosition="none"
               uiImageButtonTextWidth="0" uiImageButtonTextHeight="32" uiButtonTextFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3"
               uiButtonTextJustification="centred" uiButtonRepeat="0" uiButtonRepeatRate="100"
               componentLayerUid="e29182f001000000feffffffffffffff" uiType="uiImageButton"/>
  </modulator>
  <modulator modulatorVstExported="1" modulatorMax="1" vstIndex="2393" modulatorIsStatic="0"
             modulatorGlobalVariable="-1" modulatorMuteOnStart="0" modulatorMute="0"
             modulatorExcludeFromSnapshot="0" modulatorValueExpression="modulatorValue"
             modulatorValueExpressionReverse="midiValue" modulatorControllerExpression="value"
             luaModulatorGetValueForMIDI="-- None" luaModulatorGetValueFromMIDI="-- None"
             modulatorLinkedToPanelProperty="-- None" modulatorLinkedToModulatorProperty="-- None"
             modulatorLinkedToModulator="-- None" modulatorLinkedToModulatorSource="1"
             modulatorLinkedToComponent="Modulator" modulatorBaseValue="0"
             modulatorCustomIndex="0" modulatorCustomName="" modulatorCustomIndexGroup="0"
             modulatorCustomNameGroup="" modulatorVstNameFormat="%n" luaModulatorValueChange="-- None"
             name="TRIGBULKDUMP" modulatorMin="0" modulatorValue="0">
    <midi midiMessageType="9" midiMessageChannelOverride="0" midiMessageChannel="1"
          midiMessageCtrlrNumber="1" midiMessageCtrlrValue="0" midiMessageMultiList=""
          midiMessageSysExFormula=""/>
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="1"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="TRIGBULKDUMP"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="0"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiSliderStyle="RotaryVerticalDrag"
               uiSliderMin="0" uiSliderMax="1" uiSliderInterval="1" uiSliderDoubleClickEnabled="1"
               uiSliderDoubleClickValue="0" uiSliderValuePosition="4" uiSliderValueHeight="12"
               uiSliderValueWidth="64" uiSliderTrackCornerSize="5" uiSliderThumbCornerSize="3"
               uiSliderThumbWidth="0" uiSliderThumbHeight="0" uiSliderThumbFlatOnLeft="0"
               uiSliderThumbFlatOnRight="0" uiSliderThumbFlatOnTop="0" uiSliderThumbFlatOnBottom="0"
               uiSliderValueTextColour="0xff000000" uiSliderValueBgColour="0xffffffff"
               uiSliderRotaryOutlineColour="0xff0000ff" uiSliderRotaryFillColour="0xff0000ff"
               uiSliderThumbColour="0xffff0000" uiSliderValueHighlightColour="0xff0000ff"
               uiSliderValueOutlineColour="0xffffffff" uiSliderTrackColour="0xff0f0f0f"
               uiSliderIncDecButtonColour="0xff0000ff" uiSliderIncDecTextColour="0xffffffff"
               uiSliderValueFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" uiSliderValueTextJustification="centred"
               uiSliderVelocitySensitivity="1" uiSliderVelocityThreshold="1"
               uiSliderVelocityOffset="0" uiSliderVelocityMode="0" uiSliderVelocityModeKeyTrigger="1"
               uiSliderSpringMode="0" uiSliderSpringValue="0" uiSliderMouseWheelInterval="1"
               uiSliderPopupBubble="0" uiType="uiSlider" componentRectangle="448 192 138 64"
               componentLayerUid="250bf00f03000000feffffffffffffff"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="debugOutputLabel" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="1"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="SYSEX OUTPUT"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiLabelBgColour="0x00000000"
               uiLabelTextColour="0xff000000" uiLabelOutline="0" uiLabelOutlineColour="ff737373"
               uiLabelJustification="centred" uiLabelFitFont="0" uiLabelFont="Courier New;20;1;0;0;0;1;0"
               uiLabelText="" uiLabelDisplaysAllValues="0" uiLabelDisplayFormat="%n(%N) = %v(%h)"
               uiLabelInputHighlightTextColour="0xffffffff" uiLabelInputHighlightColour="0xff0000ff"
               uiLabelEditOnSingleClick="0" uiLabelEditOnDoubleClick="0" uiLabelEditFocusDiscardsChanges="1"
               uiLabelInputAllowedChars="" uiLabelInputMaxLength="1024" uiLabelChangedCbk="-- None"
               componentBubbleRoundAngle="10" componentBubbleBackgroundColour1="0x9cffffff"
               componentBubbleBackgroundColour2="0xbab9b9b9" componentBubbleBackgroundGradientType="1"
               componentBubbleValueColour="0xff000000" componentBubbleValueFont="&lt;Sans-Serif&gt;;14;0;0;0;0;1;3"
               componentBubbleValueJustification="centred" componentBubbleNameColour="0xff000000"
               componentBubbleNameFont="&lt;Sans-Serif&gt;;14;0;0;0;0;1;3" componentBubbleNameJustification="centred"
               componentRectangle="32 248 559 72" uiType="uiLabel" componentLayerUid="e29182f001000000feffffffffffffff"/>
  </modulator>
  <modulator modulatorVstExported="1" modulatorMax="1" vstIndex="2394" modulatorIsStatic="0"
             modulatorGlobalVariable="-1" modulatorMuteOnStart="0" modulatorMute="0"
             modulatorExcludeFromSnapshot="0" modulatorValueExpression="modulatorValue"
             modulatorValueExpressionReverse="midiValue" modulatorControllerExpression="value"
             luaModulatorGetValueForMIDI="-- None" luaModulatorGetValueFromMIDI="-- None"
             modulatorLinkedToPanelProperty="-- None" modulatorLinkedToModulatorProperty="-- None"
             modulatorLinkedToModulator="-- None" modulatorLinkedToModulatorSource="1"
             modulatorLinkedToComponent="Modulator" modulatorBaseValue="0"
             modulatorCustomIndex="11" modulatorCustomName="" modulatorCustomIndexGroup="0"
             modulatorCustomNameGroup="" modulatorVstNameFormat="%n" luaModulatorValueChange="killtimer"
             name="KILLSWITCH" modulatorMin="0" modulatorValue="0">
    <midi midiMessageType="9" midiMessageChannelOverride="0" midiMessageChannel="1"
          midiMessageCtrlrNumber="1" midiMessageCtrlrValue="0" midiMessageMultiList=""
          midiMessageSysExFormula=""/>
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="1"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="CANCEL !!"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiImageButtonMode="1"
               uiImageButtonResource="JV1010_GenericToneChange" componentRectangle="496 128 118 40"
               resourceImageWidth="64" resourceImageHeight="24" resourceImagePaintMode="36"
               resourceImageOrientation="1" uiImageButtonTextColour="0xff000000"
               uiImageButtonContent="False&#10;True" uiImageButtonTextPosition="none"
               uiImageButtonTextWidth="0" uiImageButtonTextHeight="32" uiButtonTextFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3"
               uiButtonTextJustification="centred" uiButtonRepeat="0" uiButtonRepeatRate="100"
               componentLayerUid="e29182f001000000feffffffffffffff" uiType="uiImageButton"/>
  </modulator>
  <modulator modulatorVstExported="1" modulatorMax="1" vstIndex="2395" modulatorIsStatic="0"
             modulatorGlobalVariable="-1" modulatorMuteOnStart="0" modulatorMute="0"
             modulatorExcludeFromSnapshot="0" modulatorValueExpression="modulatorValue"
             modulatorValueExpressionReverse="midiValue" modulatorControllerExpression="value"
             luaModulatorGetValueForMIDI="-- None" luaModulatorGetValueFromMIDI="-- None"
             modulatorLinkedToPanelProperty="-- None" modulatorLinkedToModulatorProperty="-- None"
             modulatorLinkedToModulator="-- None" modulatorLinkedToModulatorSource="1"
             modulatorLinkedToComponent="Modulator" modulatorBaseValue="0"
             modulatorCustomIndex="0" modulatorCustomName="" modulatorCustomIndexGroup="0"
             modulatorCustomNameGroup="" modulatorVstNameFormat="%n" luaModulatorValueChange="prepareFileSave"
             name="SAVETOFILE" modulatorMin="0" modulatorValue="0">
    <midi midiMessageType="9" midiMessageChannelOverride="0" midiMessageChannel="1"
          midiMessageCtrlrNumber="1" midiMessageCtrlrValue="0" midiMessageMultiList=""
          midiMessageSysExFormula=""/>
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="1"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="Save to SYSEX fiile?"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiImageButtonMode="1"
               uiImageButtonResource="JV1010_GenericToneChange" componentRectangle="496 80 118 40"
               resourceImageWidth="64" resourceImageHeight="24" resourceImagePaintMode="36"
               resourceImageOrientation="1" uiImageButtonTextColour="0xff000000"
               uiImageButtonContent="False&#10;True" uiImageButtonTextPosition="none"
               uiImageButtonTextWidth="0" uiImageButtonTextHeight="32" uiButtonTextFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3"
               uiButtonTextJustification="centred" uiButtonRepeat="0" uiButtonRepeatRate="100"
               componentLayerUid="e29182f001000000feffffffffffffff" uiType="uiImageButton"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="PROGRESSBAR" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="ff38df73"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="modulator-1"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="15.300000000000001"
               componentEffectColour="ff000000" componentEffectOffsetX="0" componentEffectOffsetY="0"
               componentExcludedFromLabelDisplay="0" componentValueDecimalPlaces="0"
               componentLuaMouseMoved="-- None" componentLuaMouseDown="-- None"
               componentLuaMouseDrag="-- None" componentLuaMouseDoubleClick="-- None"
               uiProgressBarBackgroundColour="ff99ccff" uiProgressBarForegroundColour="ffffffff"
               uiProgressBarDisplayPercent="0" componentRectangle="30 192 329 38"
               componentLayerUid="e29182f001000000feffffffffffffff" uiType="uiProgressBar"
               uiLabelFont="Courier New;20;1;0;0;0;1;0"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="JDLOGO" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName=""
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiImageResource="JD-990_logo"
               uiType="uiImage" componentRectangle="117 32 160 23" componentLayerUid="e29182f001000000feffffffffffffff"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="TITLE" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;1;0;0;0;0;1;3" componentVisibleName=""
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiLabelBgColour="0x00000000"
               uiLabelTextColour="0xff000000" uiLabelOutline="0" uiLabelOutlineColour="0x00000000"
               uiLabelJustification="centred" uiLabelFitFont="0" uiLabelFont="Electronic Highway Sign;14;0;0;0;0;1;2"
               uiLabelText="Roland JD-990 Synthesizer Module&#10;Sysex Dump Utility&#10;(Transfer Internal Patch I-11 ~ I-88)"
               uiLabelDisplaysAllValues="0" uiLabelDisplayFormat="%n(%N) = %v(%h)"
               uiLabelInputHighlightTextColour="0xffffffff" uiLabelInputHighlightColour="0xff0000ff"
               uiLabelEditOnSingleClick="0" uiLabelEditOnDoubleClick="0" uiLabelEditFocusDiscardsChanges="1"
               uiLabelInputAllowedChars="" uiLabelInputMaxLength="1024" uiLabelChangedCbk="-- None"
               uiType="uiLabel" componentRectangle="40 41 323 125" componentLayerUid="e29182f001000000feffffffffffffff"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="PROG" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;10;0;0;0;0;1;3" componentVisibleName="modulator-1"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="9.9000000000000004"
               componentEffectColour="0xff000000" componentEffectOffsetX="0"
               componentEffectOffsetY="18" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiLabelBgColour="0x00000000"
               uiLabelTextColour="ff000000" uiLabelOutline="0" uiLabelOutlineColour="0x00000000"
               uiLabelJustification="centred" uiLabelFitFont="0" uiLabelFont="&lt;Monospaced&gt;;14;0;0;0;0;1;3"
               uiLabelText="" uiLabelDisplaysAllValues="0" uiLabelDisplayFormat="%n(%N) = %v(%h)"
               uiLabelInputHighlightTextColour="0xffffffff" uiLabelInputHighlightColour="0xff0000ff"
               uiLabelEditOnSingleClick="0" uiLabelEditOnDoubleClick="0" uiLabelEditFocusDiscardsChanges="1"
               uiLabelInputAllowedChars="" uiLabelInputMaxLength="1024" uiLabelChangedCbk="-- None"
               uiType="uiLabel" componentRectangle="53 136 294 49" componentLayerUid="e29182f001000000feffffffffffffff"/>
  </modulator>
  <modulator modulatorVstExported="1" modulatorMax="1" vstIndex="2396" modulatorIsStatic="0"
             modulatorGlobalVariable="-1" modulatorMuteOnStart="0" modulatorMute="0"
             modulatorExcludeFromSnapshot="0" modulatorValueExpression="modulatorValue"
             modulatorValueExpressionReverse="midiValue" modulatorControllerExpression="value"
             luaModulatorGetValueForMIDI="-- None" luaModulatorGetValueFromMIDI="-- None"
             modulatorLinkedToPanelProperty="-- None" modulatorLinkedToModulatorProperty="-- None"
             modulatorLinkedToModulator="-- None" modulatorLinkedToModulatorSource="1"
             modulatorLinkedToComponent="Modulator" modulatorBaseValue="0"
             modulatorCustomIndex="0" modulatorCustomName="" modulatorCustomIndexGroup="0"
             modulatorCustomNameGroup="" modulatorVstNameFormat="%n" luaModulatorValueChange="myResetProgram"
             name="RESETSWITCH" modulatorMin="0" modulatorValue="0">
    <midi midiMessageType="9" midiMessageChannelOverride="0" midiMessageChannel="1"
          midiMessageCtrlrNumber="1" midiMessageCtrlrValue="0" midiMessageMultiList=""
          midiMessageSysExFormula=""/>
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="1"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="RESET Prog."
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiImageButtonMode="1"
               uiImageButtonResource="JV1010_GenericToneChange" componentRectangle="496 176 118 40"
               resourceImageWidth="64" resourceImageHeight="24" resourceImagePaintMode="36"
               resourceImageOrientation="1" uiImageButtonTextColour="0xff000000"
               uiImageButtonContent="False&#10;True" uiImageButtonTextPosition="none"
               uiImageButtonTextWidth="0" uiImageButtonTextHeight="32" uiButtonTextFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3"
               uiButtonTextJustification="centred" uiButtonRepeat="0" uiButtonRepeatRate="100"
               componentLayerUid="e29182f001000000feffffffffffffff" uiType="uiImageButton"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="TRATE" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="1"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="Transfer Rate Delay&#10;"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiLabelBgColour="0x00000000"
               uiLabelTextColour="0xff000000" uiLabelOutline="1" uiLabelOutlineColour="ff000000"
               uiLabelJustification="centred" uiLabelFitFont="0" uiLabelFont="&lt;Sans-Serif&gt;;22;0;0;0;0;1;3"
               uiLabelText="400" uiLabelDisplaysAllValues="0" uiLabelDisplayFormat="%n(%N) = %v(%h)"
               uiLabelInputHighlightTextColour="0xffffffff" uiLabelInputHighlightColour="0xff0000ff"
               uiLabelEditOnSingleClick="1" uiLabelEditOnDoubleClick="0" uiLabelEditFocusDiscardsChanges="1"
               uiLabelInputAllowedChars="0123456789" uiLabelInputMaxLength="4"
               uiLabelChangedCbk="-- None" uiType="uiLabel" componentRectangle="368 192 121 38"
               componentLayerUid="e29182f001000000feffffffffffffff" value="360"
               labelText="360"/>
  </modulator>
  <modulator modulatorVstExported="1" modulatorMax="1" vstIndex="2399" modulatorIsStatic="0"
             modulatorGlobalVariable="-1" modulatorMuteOnStart="0" modulatorMute="0"
             modulatorExcludeFromSnapshot="0" modulatorValueExpression="modulatorValue"
             modulatorValueExpressionReverse="midiValue" modulatorControllerExpression="value"
             luaModulatorGetValueForMIDI="-- None" luaModulatorGetValueFromMIDI="-- None"
             modulatorLinkedToPanelProperty="-- None" modulatorLinkedToModulatorProperty="-- None"
             modulatorLinkedToModulator="-- None" modulatorLinkedToModulatorSource="1"
             modulatorLinkedToComponent="Modulator" modulatorBaseValue="0"
             modulatorCustomIndex="0" modulatorCustomName="" modulatorCustomIndexGroup="0"
             modulatorCustomNameGroup="" modulatorVstNameFormat="%n" luaModulatorValueChange="uploadSysex"
             name="UPLOADFILE" modulatorMin="0" modulatorValue="0">
    <midi midiMessageType="9" midiMessageChannelOverride="0" midiMessageChannel="1"
          midiMessageCtrlrNumber="1" midiMessageCtrlrValue="0" midiMessageMultiList=""
          midiMessageSysExFormula=""/>
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="1"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="UPLOAD TO JD-990"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiImageButtonMode="1"
               uiImageButtonResource="JV1010_GenericToneChange" componentRectangle="370 32 106 40"
               resourceImageWidth="64" resourceImageHeight="24" resourceImagePaintMode="36"
               resourceImageOrientation="1" uiImageButtonTextColour="0xff000000"
               uiImageButtonContent="False&#10;True" uiImageButtonTextPosition="none"
               uiImageButtonTextWidth="0" uiImageButtonTextHeight="32" uiButtonTextFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3"
               uiButtonTextJustification="centred" uiButtonRepeat="0" uiButtonRepeatRate="100"
               uiType="uiImageButton" componentLayerUid="e29182f001000000feffffffffffffff"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="L_UNLOCK" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName=""
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiLabelBgColour="0x00000000"
               uiLabelTextColour="6c000000" uiLabelOutline="0" uiLabelOutlineColour="0x00000000"
               uiLabelJustification="left" uiLabelFitFont="0" uiLabelFont="Invasion2000;12;1;0;0;0;1;2"
               uiLabelText="[1] UTILITY&#10;[2] Protect [F6]&#10;[3] Internal Protect [OFF]"
               uiLabelDisplaysAllValues="0" uiLabelDisplayFormat="%n(%N) = %v(%h)"
               uiLabelInputHighlightTextColour="0xffffffff" uiLabelInputHighlightColour="0xff0000ff"
               uiLabelEditOnSingleClick="0" uiLabelEditOnDoubleClick="0" uiLabelEditFocusDiscardsChanges="1"
               uiLabelInputAllowedChars="" uiLabelInputMaxLength="1024" uiLabelChangedCbk="-- None"
               componentLayerUid="e29182f001000000feffffffffffffff" componentRectangle="370 118 132 45"
               uiType="uiLabel"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="ARROW" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="modulator-1"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiArrowColour="0xff000000"
               componentRectangle="408 73 32 41" uiArrowLineThickness="2" uiArrowHeadWidth="8"
               uiArrowHeadHeight="16" uiArrowOrientation="1" uiArrowRotation="0"
               uiArrowStokeThickness="1" componentLayerUid="e29182f001000000feffffffffffffff"
               uiType="uiArrow"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="VERSION" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="8c000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="modulator-1"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiLabelBgColour="0x00000000"
               uiLabelTextColour="49000000" uiLabelOutline="0" uiLabelOutlineColour="0x00000000"
               uiLabelJustification="centred" uiLabelFitFont="0" uiLabelFont="&lt;Sans-Serif&gt;;14;0;0;0;0;1;3"
               uiLabelText="Version: 1.5 " uiLabelDisplaysAllValues="0" uiLabelDisplayFormat="%n(%N) = %v(%h)"
               uiLabelInputHighlightTextColour="0xffffffff" uiLabelInputHighlightColour="0xff0000ff"
               uiLabelEditOnSingleClick="0" uiLabelEditOnDoubleClick="0" uiLabelEditFocusDiscardsChanges="1"
               uiLabelInputAllowedChars="" uiLabelInputMaxLength="1024" uiLabelChangedCbk="-- None"
               componentLayerUid="e29182f001000000feffffffffffffff" componentRectangle="160 51 88 30"
               uiType="uiLabel"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="SHOWMENU" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="modulator-1"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="1" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="menuDisplay" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiImageResource="down_arrow"
               componentLayerUid="e29182f001000000feffffffffffffff" componentRectangle="16 8 12 10"
               uiType="uiImage"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="SIZEOFDUMP" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="1"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="8c000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="Downloading"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiLabelBgColour="0x00000000"
               uiLabelTextColour="FFFF0000" uiLabelOutline="0" uiLabelOutlineColour="0x00000000"
               uiLabelJustification="centred" uiLabelFitFont="0" uiLabelFont="&lt;Sans-Serif&gt;;14;1;0;0;0;1;3"
               uiLabelText="0 bytes" uiLabelDisplaysAllValues="0" uiLabelDisplayFormat="%n(%N) = %v(%h)"
               uiLabelInputHighlightTextColour="0xffffffff" uiLabelInputHighlightColour="0xff0000ff"
               uiLabelEditOnSingleClick="0" uiLabelEditOnDoubleClick="0" uiLabelEditFocusDiscardsChanges="1"
               uiLabelInputAllowedChars="" uiLabelInputMaxLength="1024" uiLabelChangedCbk="-- None"
               componentLayerUid="e29182f001000000feffffffffffffff" componentRectangle="200 328 205 33"
               uiType="uiLabel"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="MILLISECONDS" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="modulator-1"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="1"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiLabelBgColour="0x00000000"
               uiLabelTextColour="ff797070" uiLabelOutline="0" uiLabelOutlineColour="0x00000000"
               uiLabelJustification="centred" uiLabelFitFont="0" uiLabelFont="&lt;Sans-Serif&gt;;14;0;1;0;0;1;3"
               uiLabelText="milliseconds" uiLabelDisplaysAllValues="0" uiLabelDisplayFormat="%n(%N) = %v(%h)"
               uiLabelInputHighlightTextColour="0xffffffff" uiLabelInputHighlightColour="0xff0000ff"
               uiLabelEditOnSingleClick="0" uiLabelEditOnDoubleClick="0" uiLabelEditFocusDiscardsChanges="1"
               uiLabelInputAllowedChars="" uiLabelInputMaxLength="1024" uiLabelChangedCbk="-- None"
               uiType="uiLabel" componentRectangle="384 224 88 24" componentLayerUid="e29182f001000000feffffffffffffff"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="SMILE" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="modulator-1"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="0"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiImageResource="smiley"
               componentLayerUid="e29182f001000000feffffffffffffff" componentRectangle="384 332 32 32"
               uiType="uiImage"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="SMILEN" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="modulator-1"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="0"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="-- None" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiImageResource="smileyn"
               uiType="uiImage" componentRectangle="384 332 32 32" componentLayerUid="e29182f001000000feffffffffffffff"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="BALLOONN" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="modulator-1"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="0"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="helpWrapper" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiImageResource="dream33216"
               uiType="uiImage" componentRectangle="424 328 70 27" componentLayerUid="e29182f001000000feffffffffffffff"/>
  </modulator>
  <modulator modulatorCustomIndex="0" modulatorCustomIndexGroup="0" modulatorIsStatic="1"
             name="BALLOON" modulatorVstExported="0" modulatorValue="0">
    <component componentLabelPosition="top" componentLabelJustification="centred"
               componentLabelHeight="14" componentLabelWidth="0" componentLabelVisible="0"
               componentLabelAlwaysOnTop="1" componentSentBack="0" componentLabelColour="0xff000000"
               componentLabelFont="&lt;Sans-Serif&gt;;12;0;0;0;0;1;3" componentVisibleName="modulator-1"
               componentMouseCursor="2" componentGroupName="" componentGroupped="0"
               componentSnapSize="0" componentIsLocked="0" componentDisabled="0"
               componentRadioGroupId="0" componentRadioGroupNotifyMidi="1" componentVisibility="0"
               componentEffect="0" componentEffectRadius="1" componentEffectColour="0xff000000"
               componentEffectOffsetX="0" componentEffectOffsetY="0" componentExcludedFromLabelDisplay="0"
               componentValueDecimalPlaces="0" componentLuaMouseMoved="-- None"
               componentLuaMouseDown="helpWrapper" componentLuaMouseDrag="-- None"
               componentLuaMouseDoubleClick="-- None" uiImageResource="dream_done33216"
               componentLayerUid="e29182f001000000feffffffffffffff" componentRectangle="424 328 70 27"
               uiType="uiImage"/>
  </modulator>
  <panelCustomData/>
</panel>
